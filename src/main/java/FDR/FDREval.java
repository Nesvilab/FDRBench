package main.java.FDR;

import com.compomics.util.experiment.biology.enzymes.Enzyme;
import com.compomics.util.experiment.identification.protein_sequences.digestion.ExtendedPeptide;
import com.compomics.util.experiment.identification.protein_sequences.digestion.IteratorFactory;
import com.compomics.util.experiment.identification.protein_sequences.digestion.SequenceIterator;
import com.compomics.util.parameters.identification.search.DigestionParameters;
import main.java.util.Cloger;
import net.sf.jfasta.FASTAElement;
import net.sf.jfasta.FASTAFileReader;
import net.sf.jfasta.impl.FASTAElementIterator;
import net.sf.jfasta.impl.FASTAFileReaderImpl;
import org.apache.commons.cli.*;
import org.apache.commons.lang3.StringUtils;
import tech.tablesaw.api.*;
import tech.tablesaw.io.csv.CsvReadOptions;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static main.java.FDR.DBGear.getDigestionPreferences;
import static main.java.FDR.DBGear.getEnzymeByIndex;

public class FDREval {


    public String q_value_column_name = "q_value";
    public String score_column_name = "-";
    public boolean score_higher_is_better = true;

    private PeptidePair peptidePair = new PeptidePair();

    /**
     * PSM, precursor, peptide, or protein
     */
    public FDRType fdp_level = FDRType.precursor;

    private static boolean export_db = false;
    private static boolean fdp_qvalue = false;

    public static boolean debug = false;

    public static boolean reverse_order_of_generated_random_peptides = false;

    /**
     * The max number of tries for generating decoy peptides.
     */
    private static int n_max_try_decoy_peptide_generation = 20;

    /**
     * The number of folds for generating decoy proteins/peptides.
     * In default, it is 1.
     */
    private static int n_fold = 1;

    public enum PickOneProtein {
        first("Pick the first one in the group"),
        last("Pick the last one in the group"),
        random("Pick one randomly"),
        as_is("No change");

        /**
         * The description.
         */
        public final String description;

        /**
         * Constructor.
         *
         * @param description the description PickOneProtein
         */
        PickOneProtein(String description) {
            this.description = description;
        }
    }

    private static PickOneProtein pick_one_protein_method = PickOneProtein.first;

    private static boolean no_shared_peptide_between_target_and_entrapment = false;

    private static final boolean shuffle_order_of_generated_random_peptides = true;
    // private static Random random_seed_for_shuffle_order_of_generated_random_peptides = new Random(2024);

    /**
     * Generate entrapment protein(s) for each target protein independently.
     */
    private static boolean generate_entrapment_protein_for_each_target_protein_independently = false;


    private static boolean checking_for_duplicates_then_random = false;

    /**
     * 0: shuffle a list of amino acid; 1: swap two amino acids and a total of N times swaps (N is the length of peptide).
     */
    private static int random_peptide_generation_method = 0;

    /**
     * This is used to store the target and decoy peptides generated by Crux
     */
    private static HashMap<String, ArrayList<String>> target2decoy = new HashMap<>();

    private static HashSet<String> valid_target_peptides = new HashSet<>();

    public static int global_random_seed = 2000;

    /**
     * Use a fixed random seed and random function for all decoy peptides generation.
     */
    private static boolean fix_random_seed = false;

    public static Fix_NC fix_nc_aa = Fix_NC.NC;

    /**
     * If r_ratio is <=0, it is not used.
     */
    public static double r_ratio = -1.0;

    public enum Fix_NC {
        N("Only fix N terminal amino acid"),
        C("Only fix C terminal amino acid"),
        NC("Fix both C and N terminal amino acids");

        /**
         * The description.
         */
        public final String description;

        /**
         * Constructor.
         *
         * @param description the description Fix_NC
         */
        Fix_NC(String description) {
            this.description = description;
        }
    }

    public static String entrapment_label = "_p_target";
    public static String decoy_label = CParameter.decoy_prefix;
    public static Label_Position entrapment_label_position = Label_Position.end;
    public static Label_Position decoy_label_position = Label_Position.start;

    /**
     * When it's true, first reverse a target protein when generating a paired entrapment protein.
     */
    public static boolean reverse_target_protein_for_entrapment_protein_generation = false;

    public enum Label_Position {
        start("Label position: start"),
        end("Label position: end");

        /**
         * The description.
         */
        public final String description;

        /**
         * Constructor.
         *
         * @param description the description Label_Position
         */
        Label_Position(String description) {
            this.description = description;
        }
    }

    public static void main(String[] args) throws ParseException, IOException {

        Options options = new Options();

        // for database generation
        options.addOption("db", true, "Protein database file");
        options.addOption("crux", true, "The peptide list generated by Crux");
        options.addOption("target_pep", true, "The target peptide list to consider");
        options.addOption("decoy", false, "Add decoy or not");
        options.addOption("clip_n_m", false, "When digesting a protein starting with amino acid M, two copies of the leading peptides (with and without the N-terminal M) are considered or not. Default is false.");
        options.addOption("fix_nc", true, "Fix N/C terminal amino acid. n/N: only N terminal, c/C: only C terminal and nc/NC/cn/CN: both (default)");

        options.addOption("o",true, "Output file");
        options.addOption("I2L",false,"Convert I to L");
        options.addOption("diann", false, "For DIA-NN");
        options.addOption("uniprot", false, "For Uniprot");
        options.addOption("prosit", false, "Generate Prosit input file");
        options.addOption("charge", true, "For prosit input: charge range, 2,3,4");
        options.addOption("nce", true, "For prosit input: NCE");
        options.addOption("enzyme",true,"Enzyme used for protein digestion. 0:Non enzyme, 1:Trypsin, 2:Trypsin (no P rule) (default), 3:Arg-C, 4:Arg-C (no P rule), 5:Arg-N, 6:Glu-C, 7:Lys-C");
        options.addOption("miss_c",true,"The max missed cleavages, default is 1");
        options.addOption("minLength", true, "The minimum length of peptide to consider, default is 7");
        options.addOption("maxLength", true, "The maximum length of peptide to consider, default is 35");
        options.addOption("export_db", false, "Export protein database or not");
        options.addOption("seed", true, "Random seed for generating decoy peptides");
        options.addOption("fix_seed", false, "Use a fixed random seed for all decoy peptides generation");
        options.addOption("fold", true, "The number of folds for generating entrapment proteins/peptides");
        options.addOption("r", true, "For FDP calculation: #entrapment/#target");
        options.addOption("use_v1", true, "Use the first version of FDP calculation for 1-fold");
        options.addOption("pick", true, "If a group has multiple proteins, how to peak one protein: first (default),last,random");
        // options.addOption("shuffle", false, "Shuffle the order of generated random peptides");

        // random shuffle
        options.addOption("a",false,"Generate entrapment protein(s) for each target protein independently");
        options.addOption("check",false,"Checking for duplicates and random shuffling");
        options.addOption("method",true,"The method to generate a random peptide: 0:shuffle (default), 1:swap");

        // multiple species entrapment
        options.addOption("ms", true, "Multiple species entrapment: Fasta files of foreign species");
        options.addOption("ns", false, "no shared peptides between entrapment and target protein");
        options.addOption("swap", false, "Reverse the order of generated random peptide sequences");

        // for FDP
        options.addOption("i", true, "PSM/peptide/precursor/protein file");
        options.addOption("score", true, "The score name for ranking precursor/peptide/protein for FDP calculation. The format could be \"score\", \"score:0\" or \"score:1\". The second part is 0 or 1, 0: lower is better, 1: higher is better");
        options.addOption("level", true, "PSM, peptide, precursor or protein");
        options.addOption("rev", false, "Reverse a target protein first when generating a paired entrapment protein");
        options.addOption("pep", true, "peptide/protein pair file");
        // for precursor pair information
        // options.addOption("dp", true, "Deep learning library");
        // options.addOption("fdp_qvalue", false, "Do q-value calculation for FDP");

        options.addOption("decoy_label", true, "Label for decoy: rev_ in default");
        options.addOption("decoy_pos", true, "Position of decoy label: 0 (start, in default); 1 (end)");
        options.addOption("entrapment_label", true, "Label for entrapment: _p_target in default");
        options.addOption("entrapment_pos", true, "Position of entrapment label: 0 (start); 1 (end, in default)");

        options.addOption("debug", false, "Print detailed information for debugging");


        options.addOption("h", false, "Print this usage information");

        CommandLineParser parser = new DefaultParser(false);
        CommandLine cmd = parser.parse(options, args);
        if (cmd.hasOption("h") || cmd.hasOption("help") || args.length == 0) {
            HelpFormatter f = new HelpFormatter();
            f.setWidth(100);
            f.setOptionComparator(null);
            System.out.println("java -Xmx2G -jar fdrbench.jar");
            f.printHelp("Options", options);
            return;
        }

        if(cmd.hasOption("clip_n_m")){
            CParameter.clip_nTerm_M = true;
        }else{
            CParameter.clip_nTerm_M = false;
        }

        if(cmd.hasOption("prosit")){
            for_prosit = true;
            if(cmd.hasOption("charge")){
                String []c= cmd.getOptionValue("charge").split(",");
                for (String s : c) {
                    precursor_charge_range.add(Integer.parseInt(s));
                }
            }else{
                precursor_charge_range.add(2);
                precursor_charge_range.add(3);
                precursor_charge_range.add(4);
            }
            if(cmd.hasOption("nce")){
                nce = Double.parseDouble(cmd.getOptionValue("nce"));
            }
        }

        if(cmd.hasOption("fdp_qvalue")){
            fdp_qvalue = true;
        }

        if(cmd.hasOption("fold")){
            n_fold = Integer.parseInt(cmd.getOptionValue("fold"));
        }
        //System.out.println("Fold: "+n_fold);

        if(cmd.hasOption("ns")){
            no_shared_peptide_between_target_and_entrapment = true;
        }

        if(cmd.hasOption("debug")){
            debug = true;
        }

        if(cmd.hasOption("swap")){
            reverse_order_of_generated_random_peptides = true;
        }

        if(cmd.hasOption("seed")){
            global_random_seed = Integer.parseInt(cmd.getOptionValue("seed"));
        }

        if(cmd.hasOption("rev")){
            reverse_target_protein_for_entrapment_protein_generation = true;
        }

        if(cmd.hasOption("fix_nc")){
            String nc = cmd.getOptionValue("fix_nc");
            if(nc.equalsIgnoreCase("nc") || nc.equalsIgnoreCase("cn")){
                fix_nc_aa = Fix_NC.NC;
            }else if(nc.equalsIgnoreCase("n")){
                fix_nc_aa = Fix_NC.N;
            }else if(nc.equalsIgnoreCase("c")) {
                fix_nc_aa = Fix_NC.C;
            }else{
                System.err.println("Invalid fix_nc option: "+nc);
                System.exit(1);
            }
        }

        if(cmd.hasOption("a")){
            generate_entrapment_protein_for_each_target_protein_independently = true;
            System.out.println("Generate entrapment protein(s) for each target protein independently");
        }

        if(cmd.hasOption("check")){
            checking_for_duplicates_then_random = true;
            System.out.println("Checking for duplicates and then random shuffling");
        }

        if(cmd.hasOption("method")){
            random_peptide_generation_method = Integer.parseInt(cmd.getOptionValue("method"));
        }

        if(cmd.hasOption("fix_seed")){
            fix_random_seed = true;
        }

        // if(cmd.hasOption("shuffle")){
        //    shuffle_order_of_generated_random_peptides = true;
        //}

        if(cmd.hasOption("target_pep")){
            load_valid_target_peptides(cmd.getOptionValue("target_pep"));
            System.out.println("Use user-provided target peptides:"+valid_target_peptides.size());
        }

        if(cmd.hasOption("decoy_label")){
            decoy_label = cmd.getOptionValue("decoy_label");
        }
        if(cmd.hasOption("decoy_pos")){
            int pos = Integer.parseInt(cmd.getOptionValue("decoy_pos"));
            if(pos == 1){
                decoy_label_position = Label_Position.end;
            }else{
                decoy_label_position = Label_Position.start;
            }
        }

        if(cmd.hasOption("entrapment_label")){
            entrapment_label = cmd.getOptionValue("entrapment_label");
        }
        if(cmd.hasOption("entrapment_pos")){
            int pos = Integer.parseInt(cmd.getOptionValue("entrapment_pos"));
            if(pos == 1){
                entrapment_label_position = Label_Position.end;
            }else{
                entrapment_label_position = Label_Position.start;
            }
        }


        if(cmd.hasOption("db")){

            if(cmd.hasOption("miss_c")){
                CParameter.maxMissedCleavages = Integer.parseInt(cmd.getOptionValue("miss_c"));
            }else{
                CParameter.maxMissedCleavages = 1;
            }

            if(cmd.hasOption("enzyme")){
                CParameter.enzyme = Integer.parseInt(cmd.getOptionValue("enzyme"));
            }else{
                CParameter.enzyme = 2;
            }

            if (cmd.hasOption("minLength")) {
                CParameter.minPeptideLength = Integer.parseInt(cmd.getOptionValue("minLength"));
            }else{
                CParameter.minPeptideLength = 7;
            }

            if (cmd.hasOption("maxLength")) {
                CParameter.maxPeptideLength = Integer.parseInt(cmd.getOptionValue("maxLength"));
            }else{
                CParameter.maxPeptideLength = 35;
            }

            if(cmd.hasOption("export_db")){
                export_db = true;
            }


            String db = cmd.getOptionValue("db");
            String out_file = cmd.getOptionValue("o");
            add_decoy = cmd.hasOption("decoy");
            if(cmd.hasOption("I2L")){
                I2L = true;
            }
            if(cmd.hasOption("level") && cmd.getOptionValue("level").equalsIgnoreCase("peptide")){
                if(cmd.hasOption("diann") && cmd.hasOption("uniprot")){
                    for_diann = true;
                    for_uniprot = true;
                }

                if(cmd.hasOption("crux")){
                    int n_r_pep = n_fold;
                    if(add_decoy){
                        n_r_pep = 2*n_fold+1;
                    }
                    target2decoy = CallCrux.load_crux_peptides(cmd.getOptionValue("crux"), n_r_pep);
                }

                if(cmd.hasOption("ms")) {
                    // multi-species as entrapment
                    generate_peptide_file_from_multiple_species_data(db,out_file,cmd.getOptionValue("ms"),n_fold);
                }else {
                    if (n_fold == 1) {
                        // n_max_try_decoy_peptide_generation = 0;
                        generate_peptide_file(db, out_file);
                    } else {
                        generate_peptide_file(db, out_file, n_fold);
                    }
                }
            }else{
                if(cmd.hasOption("diann") && cmd.hasOption("uniprot")){
                    for_diann = true;
                    for_uniprot = true;
                }
                if(cmd.hasOption("ms")) {
                    // multi-species as entrapment
                    generate_protein_entrapment_database_from_multiple_species_data(db,out_file,cmd.getOptionValue("ms"),n_fold);
                }else{
                    generate_protein_entrapment_database(db, out_file, n_fold);
                }
            }
            FDREval fdrEval = new FDREval();
            fdrEval.print_parameter(true);
        }

        if(cmd.hasOption("i")){
            String psm_file = cmd.getOptionValue("i");
            String pep_file = "-";
            if(cmd.hasOption("pep")) {
                pep_file = cmd.getOptionValue("pep");
            }
            String out_file = cmd.getOptionValue("o");
            String level = cmd.getOptionValue("level");
            FDREval fdrEval = new FDREval();
            if(cmd.hasOption("score")){
                String []s= cmd.getOptionValue("score").split(":");
                fdrEval.score_column_name = s[0];
                fdrEval.score_higher_is_better = s[1].equalsIgnoreCase("1");
            }
            if(level.equalsIgnoreCase("protein")){
                fdrEval.fdp_level = FDRType.protein;
            }else if(level.equalsIgnoreCase("peptide")) {
                fdrEval.fdp_level = FDRType.peptide;
            }else if(level.equalsIgnoreCase("precursor")) {
                fdrEval.fdp_level = FDRType.precursor;
            }else if (level.equalsIgnoreCase("psm")) {
                fdrEval.fdp_level = FDRType.psm;
            }else{
                System.err.println("Invalid FDR level: "+level);
                System.exit(1);
            }
            String target_col_name = "-";
            if(fdrEval.fdp_level.equals(FDRType.protein)){
                target_col_name = "protein";
            }else{
                target_col_name = "peptide";
            }
            System.out.println("FDP level: "+level);

            if(cmd.hasOption("pick")){
                if(cmd.getOptionValue("pick").equalsIgnoreCase("first")){
                    pick_one_protein_method = PickOneProtein.first;
                }else if(cmd.getOptionValue("pick").equalsIgnoreCase("last")){
                    pick_one_protein_method = PickOneProtein.last;
                }else if(cmd.getOptionValue("pick").equalsIgnoreCase("random")) {
                    pick_one_protein_method = PickOneProtein.random;
                }else if(cmd.getOptionValue("pick").equalsIgnoreCase("as_is")) {
                    pick_one_protein_method = PickOneProtein.as_is;
                }else{
                    System.err.println("Invalid pick method: "+cmd.getOptionValue("pick"));
                    System.exit(1);
                }
            }

            if(cmd.hasOption("r")){
                System.out.println("Use combined entrapment method ...");
                r_ratio = Double.parseDouble(cmd.getOptionValue("r"));
                fdrEval.calc_fdp_fast_combined_entrapment_method(psm_file,pep_file,out_file, Double.parseDouble(cmd.getOptionValue("r")));
            }else {
                //fdrEval.calc_fdp(psm_file, pep_file, target_col_name, out_file);
                if (n_fold == 1) {
                    if (cmd.hasOption("use_v1")) {
                        System.out.println("Use the first version of FDP calculation for 1-fold");
                        fdrEval.calc_fdp_fast(psm_file, pep_file, target_col_name, out_file);
                    } else {
                        System.out.println("Use the new version of FDP calculation for 1-fold");
                        fdrEval.calc_fdp_fast_kfold(psm_file, pep_file, target_col_name, out_file);
                    }
                } else {
                    fdrEval.calc_fdp_fast_kfold(psm_file, pep_file, target_col_name, out_file);
                }
            }
            fdrEval.print_parameter(false);
        }



    }

    public void print_parameter(boolean db_generation){
        System.out.println("================== parameters ==================");
        if(db_generation) {
            // protein digestion
            System.out.println("Enzyme: " + getEnzymeByIndex(CParameter.enzyme).getName());
            System.out.println("Max allowed missed cleavages: " + CParameter.maxMissedCleavages);
            System.out.println("Peptide length range: " + CParameter.minPeptideLength + " - " + CParameter.maxPeptideLength);
            System.out.println("Clip N-terminal M: " + CParameter.clip_nTerm_M);
            System.out.println("Fix N/C terminal amino acid: " + fix_nc_aa.description);
            System.out.println("Add decoy: " + add_decoy);
            System.out.println("Convert I to L: " + I2L);
            System.out.println("N fold:" + n_fold);
            System.out.println("No shared peptides between target and entrapment proteins when using foreign species: " + no_shared_peptide_between_target_and_entrapment);
            if (!valid_target_peptides.isEmpty()) {
                System.out.println("Use user-provided target peptides:" + valid_target_peptides.size());
            }
            System.out.println("Reverse order of generated random peptides:" + reverse_order_of_generated_random_peptides);
            System.out.println("Max number of tries for generating decoy peptides: " + n_max_try_decoy_peptide_generation);
            System.out.println("For DIA-NN: " + for_diann);
            System.out.println("Use Uniprot format protein ID: " + for_uniprot);
            if (for_prosit) {
                System.out.println("For Prosit: " + for_prosit);
                System.out.println("Precursor charge range: " + StringUtils.join(precursor_charge_range, ","));
                System.out.println("NCE: " + nce);
            }
            if(reverse_target_protein_for_entrapment_protein_generation){
                System.out.println("Reverse a target protein first when generating a paired entrapment protein: true");
            }
        }else{
            // FDR calculation
            System.out.println("FDR level:" + this.fdp_level.description);
            System.out.println("Score column name: " + this.score_column_name);
            System.out.println("Score higher is better: " + this.score_higher_is_better);
            if(r_ratio > 0){
                System.out.println("r ratio:" + r_ratio);
            }else {
                System.out.println("N fold:" + n_fold);
            }
            System.out.println("Pick a representative protein:" + pick_one_protein_method.description);
        }
        System.out.println("Global random seed: "+global_random_seed);
        System.out.println("================================================");
    }


    public static boolean add_decoy=true;
    public static boolean I2L = false;

    public static boolean for_diann = false;
    public static boolean for_uniprot = false;


    // for prosit input.
    public static boolean for_prosit = false;

    public static ArrayList<Integer> precursor_charge_range = new ArrayList<>();

    public static double nce = 30;


    /**
     * Generates a peptide file from a protein database.
     *
     * @param db The path of input protein database file.
     * @param out_file The path of the output file in which the peptide file will be stored.
     * @return A set of peptides generated from the protein database.
     * @throws IOException I/O error.
     */
    public static Set<String> generate_peptide_file(String db, String out_file) throws IOException {

        HashMap<String,HashSet<String>> pro2peptides = new HashMap<>();

        BufferedWriter prositWriter = null;
        if(for_prosit){
            String prosit_pep_file;
            if(out_file.endsWith(".tsv")) {
                prosit_pep_file = out_file.replaceAll(".tsv$", "_prosit.csv");
            }else if(out_file.endsWith(".txt")){
                prosit_pep_file = out_file.replaceAll(".txt$", "_prosit.csv");
            }else{
                prosit_pep_file = out_file+"_prosit.csv";
            }
            prositWriter = new BufferedWriter(new FileWriter(new File(prosit_pep_file)));
            prositWriter.write("modified_sequence,collision_energy,precursor_charge,fragmentation,proteins\n");
        }

        // pep fasta database
        String pep_fasta_file = "";
        if(out_file.endsWith(".tsv")) {
            pep_fasta_file = out_file.replaceAll(".tsv$", ".fasta");
        }else if(out_file.endsWith(".txt")){
            pep_fasta_file = out_file.replaceAll(".txt$", ".fasta");
        }else{
            pep_fasta_file = out_file+".fasta";
        }
        BufferedWriter pep_fasta_writer = new BufferedWriter(new FileWriter(new File(pep_fasta_file)));

        long startTime = System.currentTimeMillis();
        // read protein database
        File dbFile = new File(db);
        FASTAFileReader reader = new FASTAFileReaderImpl(dbFile);
        FASTAElementIterator it = reader.getIterator();

        Enzyme enzyme = getEnzymeByIndex(CParameter.enzyme);
        // Some uniprot proteins may have the same accession number.
        HashSet<String> uniprot_accs = new HashSet<>();

        HashMap<String,ArrayList<String>> pep2proteins = new HashMap<>();
        DBGear dbGear = new DBGear();
        int i = 0;
        while (it.hasNext()) {
            FASTAElement el = it.next();
            el.setLineLength(1);
            i++;
            String []headLine = el.getHeader().split("\\s+");
            String proID = headLine[0];
            if(for_diann && for_uniprot) {
                String [] acc_list = proID.split("\\|");
                if (uniprot_accs.contains(acc_list[1])) {
                    System.err.println("Duplicate accession number: " + acc_list[1]);
                    acc_list[1] = acc_list[1] + "_i" + i;
                    proID = StringUtils.join(acc_list, "|");
                    System.err.println("Use accession number: " + acc_list[1]+", new ID:"+proID);
                } else {
                    uniprot_accs.add(acc_list[1]);
                }
            }
            String proSeq = el.getSequence();
            if(I2L){
                proSeq = proSeq.replaceAll("I","L");
            }

            if(proSeq.contains("B")){
                // 'N', 'D'
                System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("B", "N");
            }
            if(proSeq.contains("Z")){
                // 'Q', 'E'
                System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("Z", "Q");
            }

            pro2peptides.put(proID, new HashSet<>());
            pro2peptides.get(proID).add(proSeq);

            HashSet<String> peps = dbGear.digest_protein(enzyme, proSeq);
            for(String pep: peps){
                if(!pep.contains("X")) {

                    if (!pep2proteins.containsKey(pep)) {
                        pep2proteins.put(pep, new ArrayList<>());
                    }
                    pep2proteins.get(pep).add(proID);
                }
            }
        }
        reader.close();

        Cloger.getInstance().logger.info("Protein sequences:" + i + ", total unique peptide sequences:" + pep2proteins.size());

        String pro_ID = "";
        String decoy_pro_ID = "";
        String entrapment_pro_ID = "";
        String decoy_entrapment_pro_ID = "";
        BufferedWriter pWriter = new BufferedWriter(new FileWriter(new File(out_file)));
        pWriter.write("sequence\tdecoy\tproteins\tpeptide_type\tpeptide_pair_index\n");
        int peptide_pair_index = 0;
        Set<String> peptides = new HashSet<>();


        boolean fix_c = false;
        boolean fix_n = false;
        if(fix_nc_aa == Fix_NC.N){
            fix_n = true;
            System.out.println("Fix N terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.C){
            fix_c = true;
            System.out.println("Fix C terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.NC){
            fix_n = true;
            fix_c = true;
            System.out.println("Fix both C and N terminal amino acids");
        }else{
            System.err.println("Invalid fix_nc_aa option: "+fix_nc_aa);
            System.exit(1);
        }
        // add all target peptides
        HashSet<String> all_peptides = new HashSet<>(pep2proteins.keySet());

        int n_ignore_valid_target_peptides = 0;
        // int rand_seed_i = global_random_seed;
        Random global_random = new Random(global_random_seed);
        for (String pep : pep2proteins.keySet()) {
            // rand_seed_i++;
            if(!valid_target_peptides.isEmpty()){
                if(!valid_target_peptides.contains(pep)){
                    System.out.println("Ignore peptide (not present in target peptide list):"+pep);
                    n_ignore_valid_target_peptides++;
                    continue;
                }
            }
            if(pep2proteins.get(pep).size()==1){
                pro_ID = pep2proteins.get(pep).get(0);
                decoy_pro_ID = CParameter.decoy_prefix+pro_ID;
                // for entrapment only. need to update for decoy
                if(for_diann && for_uniprot){
                    entrapment_pro_ID = format_uniprot_protein_id(pro_ID,";","_p_target","");
                }else{
                    entrapment_pro_ID = pro_ID + "_p_target";
                }
                decoy_entrapment_pro_ID = CParameter.decoy_prefix+entrapment_pro_ID;
            }else{
                pro_ID = StringUtils.join(pep2proteins.get(pep),';');
                // for entrapment only. need to update for decoy
                if(for_diann && for_uniprot){
                    entrapment_pro_ID = format_uniprot_protein_id(pro_ID,";","_p_target","");
                }else{
                    entrapment_pro_ID = pro_ID + "_p_target";
                }
                ArrayList<String> decoy_pro_IDs = new ArrayList<>();
                // ArrayList<String> entrapment_pro_IDs = new ArrayList<>();
                ArrayList<String> decoy_entrapment_pro_IDs = new ArrayList<>();
                for(String pro: pep2proteins.get(pep)){
                    decoy_pro_IDs.add(CParameter.decoy_prefix+pro);
                    // entrapment_pro_IDs.add(pro+"_p_target");
                    decoy_entrapment_pro_IDs.add(CParameter.decoy_prefix+pro+"_p_target");
                }
                decoy_pro_ID = StringUtils.join(decoy_pro_IDs,';');
                // entrapment_pro_ID = StringUtils.join(entrapment_pro_IDs,';');
                decoy_entrapment_pro_ID = StringUtils.join(decoy_entrapment_pro_IDs,';');
            }

            // for each peptide, generate one decoy peptide or multiple decoy peptides
            ArrayList<String> rnd_peptides = new ArrayList<>();
            if(target2decoy.isEmpty()){
                rnd_peptides = generateShufflePeptidesFast(pep,3,fix_c,fix_n,all_peptides,global_random, n_max_try_decoy_peptide_generation);
            }else{
                if(target2decoy.containsKey(pep)) {
                    rnd_peptides = target2decoy.get(pep);
                }
            }

            if(rnd_peptides.size()!=3){
                System.out.println("Ignore peptide: "+pep+", "+ rnd_peptides.size());
                continue;
            }

            boolean valid = true;
            for(String r_pep: rnd_peptides){
                if(pep2proteins.containsKey(r_pep)){
                    System.out.println("Ignore peptide: "+pep+", a decoy peptide ("+r_pep+") is matched to another target peptide");
                    valid = false;
                    break;
                }

            }
            if(!valid){
                continue;
            }

            if(shuffle_order_of_generated_random_peptides){
                // random shuffle rnd_peptides
                // Collections.shuffle(rnd_peptides, random_seed_for_shuffle_order_of_generated_random_peptides);
                Collections.shuffle(rnd_peptides, global_random);
            }

            if(reverse_order_of_generated_random_peptides) {
                // reverse rnd_peptides
                Collections.reverse(rnd_peptides);
            }

            peptides.add(pep);
            peptides.addAll(rnd_peptides);

            // save all target peptides and the decoy peptides generated so far.
            all_peptides.addAll(rnd_peptides);

            pWriter.write(pep                +"\tNo\t" +pro_ID+"\ttarget\t"+peptide_pair_index+"\n");
            pWriter.write(rnd_peptides.get(0)+"\tNo\t" +entrapment_pro_ID+"\tp_target\t"+peptide_pair_index+"\n");
            if(for_uniprot){
                pep_fasta_writer.write(">sp|"+pep+"_target|"+pep+"_target\n"+pep+"\n");
                pep_fasta_writer.write(">sp|"+rnd_peptides.get(0)+"_p_target|"+rnd_peptides.get(0)+"_p_target\n"+rnd_peptides.get(0)+"\n");
            }else{
                pep_fasta_writer.write(">"+pep+"\n"+pep+"\n");
                pep_fasta_writer.write(">"+rnd_peptides.get(0)+"\n"+rnd_peptides.get(0)+"\n");
            }

            if(for_prosit && prositWriter!=null){
                // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                // ASPTQPIQL,31,1,HCD,P04264
                // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                for(int c: precursor_charge_range){
                    prositWriter.write(pep+","+nce+","+c+",HCD,"+pro_ID+"\n");
                }

                for(int c: precursor_charge_range){
                    prositWriter.write(rnd_peptides.get(0)+","+nce+","+c+",HCD,"+entrapment_pro_ID+"\n");
                }
            }
            
            if(export_db){
                String [] entrapment_pro_ID_list = entrapment_pro_ID.split(";");
                for(String id: entrapment_pro_ID_list){
                    if(!pro2peptides.containsKey(id)){
                        pro2peptides.put(id, new HashSet<>());
                    }
                    pro2peptides.get(id).add(rnd_peptides.get(0));
                }

            }

            if(add_decoy) {
                pWriter.write(rnd_peptides.get(1) + "\tYes\t" + decoy_pro_ID + "\tdecoy\t" + peptide_pair_index + "\n");
                pWriter.write(rnd_peptides.get(2) + "\tYes\t" + decoy_entrapment_pro_ID + "\tp_decoy\t" + peptide_pair_index + "\n");

                if(for_uniprot){
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+"sp|"+rnd_peptides.get(1)+"_decoy|"+rnd_peptides.get(1)+"_decoy\n"+rnd_peptides.get(1)+"\n");
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+"sp|"+rnd_peptides.get(2)+"_p_decoy|"+rnd_peptides.get(2)+"_p_decoy\n"+rnd_peptides.get(2)+"\n");
                }else{
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+rnd_peptides.get(1)+"\n"+rnd_peptides.get(1)+"\n");
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+rnd_peptides.get(2)+"\n"+rnd_peptides.get(2)+"\n");
                }

                if(for_prosit && prositWriter!=null){
                    // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                    // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                    // ASPTQPIQL,31,1,HCD,P04264
                    // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                    for(int c: precursor_charge_range){
                        prositWriter.write(rnd_peptides.get(1)+","+nce+","+c+",HCD,"+decoy_pro_ID+"\n");
                    }

                    for(int c: precursor_charge_range){
                        prositWriter.write(rnd_peptides.get(2)+","+nce+","+c+",HCD,"+decoy_entrapment_pro_ID+"\n");
                    }
                }

                if(export_db){
                    if(!pro2peptides.containsKey(decoy_pro_ID)){
                        pro2peptides.put(decoy_pro_ID, new HashSet<>());
                    }
                    pro2peptides.get(decoy_pro_ID).add(rnd_peptides.get(1));

                    if(!pro2peptides.containsKey(decoy_entrapment_pro_ID)){
                        pro2peptides.put(decoy_entrapment_pro_ID, new HashSet<>());
                    }
                    pro2peptides.get(decoy_entrapment_pro_ID).add(rnd_peptides.get(2));
                }
            }
            peptide_pair_index = peptide_pair_index + 1;
        }

        pWriter.close();
        pep_fasta_writer.close();

        if(for_prosit && prositWriter!=null){
            prositWriter.close();
        }

        if(export_db) {
            // output proteins to a protein FASTA file
            String protein_file;
            if (out_file.endsWith(".tsv")) {
                protein_file = out_file.replaceAll(".tsv$", "_protein.fasta");
            } else if (out_file.endsWith(".txt")) {
                protein_file = out_file.replaceAll(".txt$", "_protein.fasta");
            } else {
                protein_file = out_file + "_protein.fasta";
            }
            BufferedWriter dbWriter = new BufferedWriter(new FileWriter(new File(protein_file)));
            for (String proID : pro2peptides.keySet()) {
                dbWriter.write(">" + proID + "\n");
                if(pro2peptides.get(proID).size()==1){
                    for (String pep : pro2peptides.get(proID)) {
                        dbWriter.write(pep + "\n");
                    }
                }else{
                    dbWriter.write(StringUtils.join(pro2peptides.get(proID),"K") + "\n");
                }
            }
            dbWriter.close();
        }

        long bTime = System.currentTimeMillis();
        if(n_ignore_valid_target_peptides>=1) {
            Cloger.getInstance().logger.info("The number of target peptides ignored:" + n_ignore_valid_target_peptides);
        }
        Cloger.getInstance().logger.info("Time used for protein digestion:" + (bTime - startTime) / 1000 + " s.");
        return peptides;

    }

    public static Set<String> generate_peptide_file_from_multiple_species_data(String db, String out_file, String multiple_species_files, double k_fold) throws IOException {

        HashMap<String,HashSet<String>> pro2peptides = new HashMap<>();

        BufferedWriter prositWriter = null;
        if(for_prosit){
            String prosit_pep_file;
            if(out_file.endsWith(".tsv")) {
                prosit_pep_file = out_file.replaceAll(".tsv$", "_prosit.csv");
            }else if(out_file.endsWith(".txt")){
                prosit_pep_file = out_file.replaceAll(".txt$", "_prosit.csv");
            }else{
                prosit_pep_file = out_file+"_prosit.csv";
            }
            prositWriter = new BufferedWriter(new FileWriter(new File(prosit_pep_file)));
            prositWriter.write("modified_sequence,collision_energy,precursor_charge,fragmentation,proteins\n");
        }

        // pep fasta database
        String pep_fasta_file = "";
        if(out_file.endsWith(".tsv")) {
            pep_fasta_file = out_file.replaceAll(".tsv$", ".fasta");
        }else if(out_file.endsWith(".txt")){
            pep_fasta_file = out_file.replaceAll(".txt$", ".fasta");
        }else{
            pep_fasta_file = out_file+".fasta";
        }
        BufferedWriter pep_fasta_writer = new BufferedWriter(new FileWriter(new File(pep_fasta_file)));

        long startTime = System.currentTimeMillis();
        // read protein database
        File dbFile = new File(db);
        FASTAFileReader reader = new FASTAFileReaderImpl(dbFile);
        FASTAElementIterator it = reader.getIterator();

        Enzyme enzyme = getEnzymeByIndex(CParameter.enzyme);
        // Some uniprot proteins may have the same accession number.
        HashSet<String> uniprot_accs = new HashSet<>();

        HashMap<String,ArrayList<String>> pep2proteins = new HashMap<>();
        DBGear dbGear = new DBGear();
        int i = 0;
        while (it.hasNext()) {
            FASTAElement el = it.next();
            el.setLineLength(1);
            i++;
            String []headLine = el.getHeader().split("\\s+");
            String proID = headLine[0];
            if(for_diann && for_uniprot) {
                String [] acc_list = proID.split("\\|");
                if (uniprot_accs.contains(acc_list[1])) {
                    System.err.println("Duplicate accession number: " + acc_list[1]);
                    acc_list[1] = acc_list[1] + "_i" + i;
                    proID = StringUtils.join(acc_list, "|");
                    System.err.println("Use accession number: " + acc_list[1]+", new ID:"+proID);
                } else {
                    uniprot_accs.add(acc_list[1]);
                }
            }
            String proSeq = el.getSequence();
            if(I2L){
                proSeq = proSeq.replaceAll("I","L");
            }

            if(proSeq.contains("B")){
                // 'N', 'D'
                System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("B", "N");
            }
            if(proSeq.contains("Z")){
                // 'Q', 'E'
                System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("Z", "Q");
            }

            pro2peptides.put(proID, new HashSet<>());
            pro2peptides.get(proID).add(proSeq);

            HashSet<String> peps = dbGear.digest_protein(enzyme, proSeq);
            for(String pep: peps){
                if(!pep.contains("X")) {

                    if (!pep2proteins.containsKey(pep)) {
                        pep2proteins.put(pep, new ArrayList<>());
                    }
                    pep2proteins.get(pep).add(proID);
                }
            }
        }
        reader.close();

        Cloger.getInstance().logger.info("Protein sequences:" + i + ", total unique peptide sequences:" + pep2proteins.size());

        String pro_ID = "";
        String decoy_pro_ID = "";
        String entrapment_pro_ID = "";
        String decoy_entrapment_pro_ID = "";
        BufferedWriter pWriter = new BufferedWriter(new FileWriter(new File(out_file)));
        pWriter.write("sequence\tdecoy\tproteins\tpeptide_type\tpeptide_pair_index\n");
        int peptide_pair_index = 0;
        Set<String> peptides = new HashSet<>();


        boolean fix_c = false;
        boolean fix_n = false;
        if(fix_nc_aa == Fix_NC.N){
            fix_n = true;
            System.out.println("Fix N terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.C){
            fix_c = true;
            System.out.println("Fix C terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.NC){
            fix_n = true;
            fix_c = true;
            System.out.println("Fix both C and N terminal amino acids");
        }else{
            System.err.println("Invalid fix_nc_aa option: "+fix_nc_aa);
            System.exit(1);
        }
        // add all target peptides
        // all_peptides: all peptides, include peptides from both target and entrapment database.
        HashSet<String> all_peptides = new HashSet<>(pep2proteins.keySet());

        // read multiple species data
        String []fs = multiple_species_files.split(",");
        System.out.println("The total number of database files:"+fs.length);

        HashSet<String> entrapment_peptides = new HashSet<>();
        // entrapment peptide to protein list
        HashMap<String,ArrayList<String>> entrapment_pep2proteins = new HashMap<>();
        int n_entrapment = 0;
        int n_ignore = 0;
        int n_shared_peptides_between_entrapment_and_target_proteins = 0;
        HashSet<String> shared_peptides_between_entrapment_and_target_proteins = new HashSet<>();
        for(String f: fs){
            try {
                dbFile = new File(f);
                reader = new FASTAFileReaderImpl(dbFile);
                it = reader.getIterator();
                // Some uniprot proteins may have the same accession number
                i = 0;
                while (it.hasNext()) {
                    FASTAElement el = it.next();
                    el.setLineLength(1);
                    i++;
                    String []headLine = el.getHeader().split("\\s+",2);
                    String proID = headLine[0];
                    String desc = headLine[1];
                    String proSeq = el.getSequence();
                    if(I2L){
                        proSeq = proSeq.replaceAll("I","L");
                    }

                    if(proSeq.contains("B")){
                        // 'N', 'D'
                        System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                        proSeq = proSeq.replaceAll("B", "N");
                    }
                    if(proSeq.contains("Z")){
                        // 'Q', 'E'
                        System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                        proSeq = proSeq.replaceAll("Z", "Q");
                    }

                    // digest protein
                    HashSet<String> peps = dbGear.digest_protein(enzyme, proSeq);
                    for(String pep: peps){
                        if(pep2proteins.containsKey(pep)){
                            n_shared_peptides_between_entrapment_and_target_proteins++;
                            shared_peptides_between_entrapment_and_target_proteins.add(pep);
                        }else{
                            if(!entrapment_pep2proteins.containsKey(pep)){
                                entrapment_pep2proteins.put(pep, new ArrayList<>());
                            }
                            entrapment_pep2proteins.get(pep).add(proID);
                        }
                    }
                    n_entrapment++;
                }
                reader.close();
                System.out.println("The total number of proteins in database "+f+": "+i);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }
        }
        System.out.println("The total number of proteins from entrapment databases:"+n_entrapment);
        System.out.println("The total number of peptides from target database:"+pep2proteins.size());
        System.out.println("The total number of peptides from entrapment databases:"+entrapment_pep2proteins.size());
        System.out.println("The total number of shared peptides between entrapment and target databases:"+shared_peptides_between_entrapment_and_target_proteins.size());
        shared_peptides_between_entrapment_and_target_proteins.clear();

        // Add all entrapment peptides.
        all_peptides.addAll(entrapment_pep2proteins.keySet());

        int n_ignore_valid_target_peptides = 0;
        // int rand_seed_i = global_random_seed;
        Random global_random = new Random(global_random_seed);

        // cannot generate a decoy peptide for them when decoy peptide is required.
        HashSet<String> invalid_target_peptides = new HashSet<>();

        // for target peptides
        int n_valid_target_peptides = 0;
        for (String pep : pep2proteins.keySet()) {
            // rand_seed_i++;
            if(pep2proteins.get(pep).size()==1){
                pro_ID = pep2proteins.get(pep).get(0);
                decoy_pro_ID = CParameter.decoy_prefix+pro_ID;
            }else{
                pro_ID = StringUtils.join(pep2proteins.get(pep),';');
                ArrayList<String> decoy_pro_IDs = new ArrayList<>();
                for(String pro: pep2proteins.get(pep)){
                    decoy_pro_IDs.add(CParameter.decoy_prefix+pro);
                }
                decoy_pro_ID = StringUtils.join(decoy_pro_IDs,';');
            }

            ArrayList<String> rnd_peptides = new ArrayList<>();
            if(add_decoy) {
                // for each peptide, generate one decoy peptide
                rnd_peptides = generateShufflePeptidesFast(pep, 1, fix_c, fix_n, all_peptides, global_random, n_max_try_decoy_peptide_generation);
                if (rnd_peptides.isEmpty()) {
                    System.out.println("Ignore peptide: " + pep);
                    // invalid target peptide
                    invalid_target_peptides.add(pep);
                    continue;
                } else {
                    all_peptides.addAll(rnd_peptides);
                }
            }

            // save all decoy peptides generated so far.
            if(!rnd_peptides.isEmpty()){
                all_peptides.addAll(rnd_peptides);
            }

            n_valid_target_peptides++;
            pWriter.write(pep+"\tNo\t" +pro_ID+"\ttarget\t"+peptide_pair_index+"\n");
            if(for_uniprot){
                pep_fasta_writer.write(">sp|"+pep+"_target|"+pep+"_target\n"+pep+"\n");
            }else{
                pep_fasta_writer.write(">"+pep+"\n"+pep+"\n");
            }

            if(for_prosit && prositWriter!=null){
                // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                // ASPTQPIQL,31,1,HCD,P04264
                // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                for(int c: precursor_charge_range){
                    prositWriter.write(pep+","+nce+","+c+",HCD,"+pro_ID+"\n");
                }
            }

            if(add_decoy) {
                pWriter.write(rnd_peptides.get(0) + "\tYes\t" + decoy_pro_ID + "\tdecoy\t" + peptide_pair_index + "\n");
                if(for_uniprot){
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+"sp|"+rnd_peptides.get(0)+"_decoy|"+rnd_peptides.get(0)+"_decoy\n"+rnd_peptides.get(0)+"\n");
                }else{
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+rnd_peptides.get(0)+"\n"+rnd_peptides.get(0)+"\n");
                }

                if(for_prosit && prositWriter!=null){
                    // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                    // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                    // ASPTQPIQL,31,1,HCD,P04264
                    // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                    for(int c: precursor_charge_range){
                        prositWriter.write(rnd_peptides.get(0)+","+nce+","+c+",HCD,"+decoy_pro_ID+"\n");
                    }
                }

                if(export_db){
                    if(!pro2peptides.containsKey(decoy_pro_ID)){
                        pro2peptides.put(decoy_pro_ID, new HashSet<>());
                    }
                    pro2peptides.get(decoy_pro_ID).add(rnd_peptides.get(0));
                }
            }
            peptide_pair_index = peptide_pair_index + 1;
        }

        // for entrapment peptides
        // cannot generate a decoy peptide for them when decoy peptide is required.
        int n_valid_entrapment_peptides = 0;
        HashSet<String> invalid_entrapment_peptides = new HashSet<>();
        // sample entrapment peptides
        ArrayList<String> entrapment_pep_list = new ArrayList<>(entrapment_pep2proteins.keySet());
        Collections.shuffle(entrapment_pep_list, global_random);
        double ratio_entrapment_to_target = 1.0*entrapment_pep_list.size()/n_valid_target_peptides;
        int n_sample_entrapment = 0;
        if(ratio_entrapment_to_target > k_fold){
            System.out.println("The ratio of entrapment peptides to target peptides is larger than the k-fold value:"+ratio_entrapment_to_target);
            n_sample_entrapment = (int)(k_fold*n_valid_target_peptides);
        }
        //for (String pep : entrapment_pep2proteins.keySet()) {
        for (String pep : entrapment_pep_list) {
            // rand_seed_i++;
            if(entrapment_pep2proteins.get(pep).size()==1){
                pro_ID = entrapment_pep2proteins.get(pep).get(0);
                decoy_pro_ID = CParameter.decoy_prefix+pro_ID;
                if(for_diann && for_uniprot){
                    entrapment_pro_ID = format_uniprot_protein_id(pro_ID,";","_p_target","");
                }else{
                    entrapment_pro_ID = pro_ID + "_p_target";
                }
                decoy_entrapment_pro_ID = CParameter.decoy_prefix+entrapment_pro_ID;
            }else{
                pro_ID = StringUtils.join(entrapment_pep2proteins.get(pep),';');
                // for entrapment only. need to update for decoy
                if(for_diann && for_uniprot){
                    entrapment_pro_ID = format_uniprot_protein_id(pro_ID,";","_p_target","");
                }else{
                    entrapment_pro_ID = pro_ID + "_p_target";
                }
                ArrayList<String> decoy_pro_IDs = new ArrayList<>();
                // ArrayList<String> entrapment_pro_IDs = new ArrayList<>();
                ArrayList<String> decoy_entrapment_pro_IDs = new ArrayList<>();
                for(String pro: entrapment_pep2proteins.get(pep)){
                    decoy_pro_IDs.add(CParameter.decoy_prefix+pro);
                    // entrapment_pro_IDs.add(pro+"_p_target");
                    decoy_entrapment_pro_IDs.add(CParameter.decoy_prefix+pro+"_p_target");
                }
                decoy_pro_ID = StringUtils.join(decoy_pro_IDs,';');
                // entrapment_pro_ID = StringUtils.join(entrapment_pro_IDs,';');
                decoy_entrapment_pro_ID = StringUtils.join(decoy_entrapment_pro_IDs,';');
            }

            ArrayList<String> rnd_peptides = new ArrayList<>();
            if(add_decoy) {
                // for each peptide, generate one decoy peptide
                rnd_peptides = generateShufflePeptidesFast(pep, 1, fix_c, fix_n, all_peptides, global_random, n_max_try_decoy_peptide_generation);
                if (rnd_peptides.isEmpty()) {
                    System.out.println("Ignore peptide: " + pep);
                    // invalid target peptide
                    invalid_entrapment_peptides.add(pep);
                    continue;
                } else {
                    all_peptides.addAll(rnd_peptides);
                }
            }

            // save all decoy peptides generated so far.
            if(!rnd_peptides.isEmpty()){
                all_peptides.addAll(rnd_peptides);
            }

            n_valid_entrapment_peptides++;
            pWriter.write(pep+"\tNo\t" +entrapment_pro_ID+"\tp_target\t"+peptide_pair_index+"\n");
            if(for_uniprot){
                pep_fasta_writer.write(">sp|"+pep+"_p_target|"+pep+"_p_target\n"+pep+"\n");
            }else{
                pep_fasta_writer.write(">"+pep+"\n"+pep+"\n");
            }

            if(for_prosit && prositWriter!=null){
                // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                // ASPTQPIQL,31,1,HCD,P04264
                // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                for(int c: precursor_charge_range){
                    prositWriter.write(pep+","+nce+","+c+",HCD,"+entrapment_pro_ID+"\n");
                }
            }


            if(export_db){
                String [] entrapment_pro_ID_list = entrapment_pro_ID.split(";");
                for(String id: entrapment_pro_ID_list){
                    if(!pro2peptides.containsKey(id)){
                        pro2peptides.put(id, new HashSet<>());
                    }
                    pro2peptides.get(id).add(pep);
                }

            }

            if(add_decoy) {
                pWriter.write(rnd_peptides.get(0) + "\tYes\t" + decoy_entrapment_pro_ID + "\tp_decoy\t" + peptide_pair_index + "\n");

                if(for_uniprot){
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+"sp|"+rnd_peptides.get(0)+"_p_decoy|"+rnd_peptides.get(0)+"_p_decoy\n"+rnd_peptides.get(0)+"\n");
                }else{
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+rnd_peptides.get(0)+"\n"+rnd_peptides.get(0)+"\n");
                }

                if(for_prosit && prositWriter!=null){
                    // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                    // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                    // ASPTQPIQL,31,1,HCD,P04264
                    // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                    for(int c: precursor_charge_range){
                        prositWriter.write(rnd_peptides.get(0)+","+nce+","+c+",HCD,"+decoy_entrapment_pro_ID+"\n");
                    }
                }

                if(export_db){
                    if(!pro2peptides.containsKey(decoy_entrapment_pro_ID)){
                        pro2peptides.put(decoy_entrapment_pro_ID, new HashSet<>());
                    }
                    pro2peptides.get(decoy_entrapment_pro_ID).add(rnd_peptides.get(0));
                }
            }
            peptide_pair_index = peptide_pair_index + 1;

            if(n_valid_entrapment_peptides==n_sample_entrapment){
                break;
            }
        }

        pWriter.close();
        pep_fasta_writer.close();

        if(for_prosit && prositWriter!=null){
            prositWriter.close();
        }

        if(export_db) {
            // output proteins to a protein FASTA file
            String protein_file;
            if (out_file.endsWith(".tsv")) {
                protein_file = out_file.replaceAll(".tsv$", "_protein.fasta");
            } else if (out_file.endsWith(".txt")) {
                protein_file = out_file.replaceAll(".txt$", "_protein.fasta");
            } else {
                protein_file = out_file + "_protein.fasta";
            }
            BufferedWriter dbWriter = new BufferedWriter(new FileWriter(new File(protein_file)));
            for (String proID : pro2peptides.keySet()) {
                dbWriter.write(">" + proID + "\n");
                if(pro2peptides.get(proID).size()==1){
                    for (String pep : pro2peptides.get(proID)) {
                        dbWriter.write(pep + "\n");
                    }
                }else{
                    dbWriter.write(StringUtils.join(pro2peptides.get(proID),"K") + "\n");
                }
            }
            dbWriter.close();
        }

        if((pep2proteins.size() - invalid_target_peptides.size())!=n_valid_target_peptides){
            System.out.println("Error: the number of valid target peptides is not correct, " + (pep2proteins.size() - invalid_target_peptides.size()) + " vs " + n_valid_target_peptides);
        }
        // if((entrapment_pep2proteins.size() - invalid_entrapment_peptides.size())!=n_valid_entrapment_peptides){
        //    System.out.println("Error: the number of valid entrapment peptides is not correct, " + (entrapment_pep2proteins.size() - invalid_entrapment_peptides.size()) + " vs " + n_valid_entrapment_peptides);
        //}

        double r_ratio = 1.0*n_valid_entrapment_peptides/n_valid_target_peptides;
        System.out.println("The ratio of entrapment peptides to target peptides: "+n_valid_entrapment_peptides + "/"+n_valid_target_peptides+" = "+r_ratio);

        long bTime = System.currentTimeMillis();
        Cloger.getInstance().logger.info("Time used for protein digestion:" + (bTime - startTime) / 1000 + " s.");
        return peptides;

    }


    public static Set<String> generate_peptide_file(String db, String out_file, int n_fold) throws IOException {

        HashMap<String,HashSet<String>> pro2peptides = new HashMap<>();

        BufferedWriter prositWriter = null;
        if(for_prosit){
            String prosit_pep_file;
            if(out_file.endsWith(".tsv")) {
                prosit_pep_file = out_file.replaceAll(".tsv$", "_prosit.csv");
            }else if(out_file.endsWith(".txt")){
                prosit_pep_file = out_file.replaceAll(".txt$", "_prosit.csv");
            }else{
                prosit_pep_file = out_file+"_prosit.csv";
            }
            prositWriter = new BufferedWriter(new FileWriter(new File(prosit_pep_file)));
            prositWriter.write("modified_sequence,collision_energy,precursor_charge,fragmentation,proteins\n");
        }

        // pep fasta database
        String pep_fasta_file = "";
        if(out_file.endsWith(".tsv")) {
            pep_fasta_file = out_file.replaceAll(".tsv$", ".fasta");
        }else if(out_file.endsWith(".txt")){
            pep_fasta_file = out_file.replaceAll(".txt$", ".fasta");
        }else{
            pep_fasta_file = out_file+".fasta";
        }
        BufferedWriter pep_fasta_writer = new BufferedWriter(new FileWriter(new File(pep_fasta_file)));

        long startTime = System.currentTimeMillis();
        // read protein database
        File dbFile = new File(db);
        FASTAFileReader reader = new FASTAFileReaderImpl(dbFile);
        FASTAElementIterator it = reader.getIterator();

        Enzyme enzyme = getEnzymeByIndex(CParameter.enzyme);
        // Some uniprot proteins may have the same accession number.
        HashSet<String> uniprot_accs = new HashSet<>();

        HashMap<String,ArrayList<String>> pep2proteins = new HashMap<>();
        DBGear dbGear = new DBGear();
        int i = 0;
        while (it.hasNext()) {
            FASTAElement el = it.next();
            el.setLineLength(1);
            i++;
            String []headLine = el.getHeader().split("\\s+");
            String proID = headLine[0];
            if(for_diann && for_uniprot) {
                String [] acc_list = proID.split("\\|");
                if (uniprot_accs.contains(acc_list[1])) {
                    System.err.println("Duplicate accession number: " + acc_list[1]);
                    acc_list[1] = acc_list[1] + "_i" + i;
                    proID = StringUtils.join(acc_list, "|");
                    System.err.println("Use accession number: " + acc_list[1]+", new ID:"+proID);
                } else {
                    uniprot_accs.add(acc_list[1]);
                }
            }
            String proSeq = el.getSequence();
            if(I2L){
                proSeq = proSeq.replaceAll("I","L");
            }

            if(proSeq.contains("B")){
                // 'N', 'D'
                System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("B", "N");
            }
            if(proSeq.contains("Z")){
                // 'Q', 'E'
                System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("Z", "Q");
            }

            pro2peptides.put(proID, new HashSet<>());
            pro2peptides.get(proID).add(proSeq);

            HashSet<String> peps = dbGear.digest_protein(enzyme, proSeq);
            for(String pep: peps){
                if(!pep.contains("X")) {

                    if (!pep2proteins.containsKey(pep)) {
                        pep2proteins.put(pep, new ArrayList<>());
                    }
                    pep2proteins.get(pep).add(proID);
                }
            }
        }
        reader.close();

        Cloger.getInstance().logger.info("Protein sequences:" + i + ", total unique peptide sequences:" + pep2proteins.size());

        String pro_ID = "";
        String decoy_pro_ID = "";
        String entrapment_pro_ID = "";
        String decoy_entrapment_pro_ID = "";
        BufferedWriter pWriter = new BufferedWriter(new FileWriter(new File(out_file)));
        pWriter.write("sequence\tdecoy\tproteins\tpeptide_type\tpeptide_pair_index\n");
        int peptide_pair_index = 0;
        Set<String> peptides = new HashSet<>();


        boolean fix_c = false;
        boolean fix_n = false;
        if(fix_nc_aa == Fix_NC.N){
            fix_n = true;
            System.out.println("Fix N terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.C){
            fix_c = true;
            System.out.println("Fix C terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.NC){
            fix_n = true;
            fix_c = true;
            System.out.println("Fix both C and N terminal amino acids");
        }else{
            System.err.println("Invalid fix_nc_aa option: "+fix_nc_aa);
            System.exit(1);
        }
        // add all target peptides
        HashSet<String> all_peptides = new HashSet<>(pep2proteins.keySet());

        int n_ignore_valid_target_peptides = 0;
        Random global_random = new Random(global_random_seed);
        for (String pep : pep2proteins.keySet()) {
            if(!valid_target_peptides.isEmpty()){
                if(!valid_target_peptides.contains(pep)){
                    System.out.println("Ignore peptide (not present in target peptide list):"+pep);
                    n_ignore_valid_target_peptides++;
                    continue;
                }
            }
            if(pep2proteins.get(pep).size()==1){
                pro_ID = pep2proteins.get(pep).get(0);
                decoy_pro_ID = CParameter.decoy_prefix+pro_ID;
                // for entrapment only. need to update for decoy
                if(for_diann && for_uniprot){
                    entrapment_pro_ID = format_uniprot_protein_id(pro_ID,";","_p_target","");
                }else{
                    entrapment_pro_ID = pro_ID + "_p_target";
                }
                decoy_entrapment_pro_ID = CParameter.decoy_prefix+entrapment_pro_ID;
            }else{
                pro_ID = StringUtils.join(pep2proteins.get(pep),';');
                // for entrapment only. need to update for decoy
                if(for_diann && for_uniprot){
                    entrapment_pro_ID = format_uniprot_protein_id(pro_ID,";","_p_target","");
                }else{
                    entrapment_pro_ID = pro_ID + "_p_target";
                }
                ArrayList<String> decoy_pro_IDs = new ArrayList<>();
                // ArrayList<String> entrapment_pro_IDs = new ArrayList<>();
                ArrayList<String> decoy_entrapment_pro_IDs = new ArrayList<>();
                for(String pro: pep2proteins.get(pep)){
                    decoy_pro_IDs.add(CParameter.decoy_prefix+pro);
                    // entrapment_pro_IDs.add(pro+"_p_target");
                    decoy_entrapment_pro_IDs.add(CParameter.decoy_prefix+pro+"_p_target");
                }
                decoy_pro_ID = StringUtils.join(decoy_pro_IDs,';');
                // entrapment_pro_ID = StringUtils.join(entrapment_pro_IDs,';');
                decoy_entrapment_pro_ID = StringUtils.join(decoy_entrapment_pro_IDs,';');
            }

            // for each peptide, generate one decoy peptide or multiple decoy peptides
            int n_r_pep = n_fold;
            if(add_decoy){
                // n_fold = 1, 3
                // n_fold = 2, 5
                n_r_pep = 2*n_fold+1;
            }
            ArrayList<String> rnd_peptides = new ArrayList<>();
            if(target2decoy.isEmpty()){
                rnd_peptides = generateShufflePeptidesFast(pep,n_r_pep,fix_c,fix_n, all_peptides, global_random, n_max_try_decoy_peptide_generation);
            }else{
                if(target2decoy.containsKey(pep)){
                    rnd_peptides = target2decoy.get(pep);
                }
            }


            if(rnd_peptides.size()<n_r_pep){
                System.out.println("Ignore peptide: "+pep+", "+ rnd_peptides.size());
                continue;
            }

            boolean valid = true;
            for(String r_pep: rnd_peptides){
                if(pep2proteins.containsKey(r_pep)){
                    System.out.println("Ignore peptide: "+pep+", a decoy peptide ("+r_pep+") is matched to another target peptide");
                    valid = false;
                    break;
                }

            }
            if(!valid){
                continue;
            }

            if(shuffle_order_of_generated_random_peptides){
                // random shuffle rnd_peptides
                //Collections.shuffle(rnd_peptides, random_seed_for_shuffle_order_of_generated_random_peptides);
                Collections.shuffle(rnd_peptides, global_random);
            }

            peptides.add(pep);
            peptides.addAll(rnd_peptides);

            // save all target peptides and the decoy peptides generated so far.
            all_peptides.addAll(rnd_peptides);

            // target peptide
            pWriter.write(pep                +"\tNo\t" +pro_ID+"\ttarget\t"+peptide_pair_index+"\n");
            // for(int j=0;j<rnd_peptides.size();j++) {
            for(int j=0;j<n_fold;j++) {
                // TODO: check if entrapment_pro_ID is needed to be different
                pWriter.write(rnd_peptides.get(j) + "\tNo\t" + entrapment_pro_ID + "\tp_target\t" + peptide_pair_index + "\n");
            }
            if(for_uniprot){
                pep_fasta_writer.write(">sp|"+pep+"_target|"+pep+"_target\n"+pep+"\n");
                //for(int j=0;j<rnd_peptides.size();j++) {
                for(int j=0;j<n_fold;j++) {
                    pep_fasta_writer.write(">sp|" + rnd_peptides.get(j) + "_p_target|" + rnd_peptides.get(j) + "_p_target\n" + rnd_peptides.get(j) + "\n");
                }
            }else{
                pep_fasta_writer.write(">"+pep+"\n"+pep+"\n");
                //for(int j=0;j<rnd_peptides.size();j++) {
                for(int j=0;j<n_fold;j++) {
                    pep_fasta_writer.write(">" + rnd_peptides.get(j) + "\n" + rnd_peptides.get(j) + "\n");
                }
            }

            if(for_prosit && prositWriter!=null){
                // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                // ASPTQPIQL,31,1,HCD,P04264
                // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                for(int c: precursor_charge_range){
                    prositWriter.write(pep+","+nce+","+c+",HCD,"+pro_ID+"\n");
                }

                for(int c: precursor_charge_range){
                    // for(int j=0;j<rnd_peptides.size();j++) {
                    for(int j=0;j<n_fold;j++) {
                        // TODO: check if entrapment_pro_ID is needed to be different
                        prositWriter.write(rnd_peptides.get(j) + "," + nce + "," + c + ",HCD," + entrapment_pro_ID + "\n");
                    }
                }
            }

            if(export_db){
                // need to check this part if this database is used for downstream analysis
                String [] entrapment_pro_ID_list = entrapment_pro_ID.split(";");
                for(String id: entrapment_pro_ID_list){
                    if(!pro2peptides.containsKey(id)){
                        pro2peptides.put(id, new HashSet<>());
                    }
                    for(int j=0;j<rnd_peptides.size();j++) {
                        pro2peptides.get(id).add(rnd_peptides.get(j));
                    }
                }

            }

            if(add_decoy) {
                int n_decoy = n_r_pep - n_fold;
                // n_fold, n_r_pep, n_decoy = 1, 3, 2
                // n_fold = 2, 5, 3
                // n_r_pep = 2*n_fold+1;
                pWriter.write(rnd_peptides.get(n_fold) + "\tYes\t" + decoy_pro_ID + "\tdecoy\t" + peptide_pair_index + "\n");
                for(int j=1;j<n_decoy;j++) {
                    pWriter.write(rnd_peptides.get(n_fold+j) + "\tYes\t" + decoy_entrapment_pro_ID + "\tp_decoy\t" + peptide_pair_index + "\n");
                }

                if(for_uniprot){
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+"sp|"+rnd_peptides.get(n_fold)+"_decoy|"+rnd_peptides.get(n_fold)+"_decoy\n"+rnd_peptides.get(n_fold)+"\n");
                    for(int j=1;j<n_decoy;j++) {
                        pep_fasta_writer.write(">"+CParameter.decoy_prefix+"sp|"+rnd_peptides.get(n_fold+j)+"_p_decoy|"+rnd_peptides.get(n_fold+j)+"_p_decoy\n"+rnd_peptides.get(n_fold+j)+"\n");
                    }
                }else{
                    pep_fasta_writer.write(">"+CParameter.decoy_prefix+rnd_peptides.get(n_fold)+"\n"+rnd_peptides.get(n_fold)+"\n");
                    for(int j=1;j<n_decoy;j++) {
                        pep_fasta_writer.write(">"+CParameter.decoy_prefix+rnd_peptides.get(n_fold+j)+"\n"+rnd_peptides.get(n_fold+j)+"\n");
                    }
                }

                if(for_prosit && prositWriter!=null){
                    // TODO: need to check if for prosit
                    // https://oktoberfest.readthedocs.io/en/latest/peptides_format.html
                    // modified_sequence,collision_energy,precursor_charge,fragmentation,proteins
                    // ASPTQPIQL,31,1,HCD,P04264
                    // KDVDGAYM[UNIMOD:35]TK,30,2,HCD,P04264;CON__P04264
                    for(int c: precursor_charge_range){
                        prositWriter.write(rnd_peptides.get(n_fold)+","+nce+","+c+",HCD,"+decoy_pro_ID+"\n");
                    }

                    for(int c: precursor_charge_range){
                        // for(int j=0;j<rnd_peptides.size();j++) {
                        for(int j=1;j<n_decoy;j++) {
                            // TODO: check if entrapment_pro_ID is needed to be different
                            prositWriter.write(rnd_peptides.get(n_fold+j) + "," + nce + "," + c + ",HCD," + decoy_entrapment_pro_ID + "\n");
                        }
                    }
                }

                if(export_db){
                    if(!pro2peptides.containsKey(decoy_pro_ID)){
                        pro2peptides.put(decoy_pro_ID, new HashSet<>());
                    }
                    pro2peptides.get(decoy_pro_ID).add(rnd_peptides.get(n_fold));

                    if(!pro2peptides.containsKey(decoy_entrapment_pro_ID)){
                        pro2peptides.put(decoy_entrapment_pro_ID, new HashSet<>());
                    }
                    for(int j=1;j<n_decoy;j++) {
                        pro2peptides.get(decoy_entrapment_pro_ID).add(rnd_peptides.get(n_fold+j));
                    }

                }
            }
            peptide_pair_index = peptide_pair_index + 1;
        }

        pWriter.close();
        pep_fasta_writer.close();

        if(for_prosit && prositWriter!=null){
            prositWriter.close();
        }

        if(export_db) {
            // output proteins to a protein FASTA file
            String protein_file;
            if (out_file.endsWith(".tsv")) {
                protein_file = out_file.replaceAll(".tsv$", "_protein.fasta");
            } else if (out_file.endsWith(".txt")) {
                protein_file = out_file.replaceAll(".txt$", "_protein.fasta");
            } else {
                protein_file = out_file + "_protein.fasta";
            }
            BufferedWriter dbWriter = new BufferedWriter(new FileWriter(new File(protein_file)));
            for (String proID : pro2peptides.keySet()) {
                dbWriter.write(">" + proID + "\n");
                if(pro2peptides.get(proID).size()==1){
                    for (String pep : pro2peptides.get(proID)) {
                        dbWriter.write(pep + "\n");
                    }
                }else{
                    dbWriter.write(StringUtils.join(pro2peptides.get(proID),"K") + "\n");
                }
            }
            dbWriter.close();
        }

        long bTime = System.currentTimeMillis();
        if(n_ignore_valid_target_peptides>=1) {
            Cloger.getInstance().logger.info("The number of target peptides ignored:" + n_ignore_valid_target_peptides);
        }
        Cloger.getInstance().logger.info("Time used for protein digestion:" + (bTime - startTime) / 1000 + " s.");
        return peptides;

    }

    private static String format_uniprot_protein_id(String proID, String sep, String prefix, String n_fold_label){
        String []d = proID.split(sep);
        String []res = new String[d.length];
        for(int i=0;i<d.length;i++) {
            String[] acc_list = d[i].split("\\|");
            res[i] = acc_list[0] + "|" + acc_list[1] + n_fold_label + prefix + "|" + acc_list[2] + n_fold_label + prefix;
        }
        return StringUtils.join(res, sep);
    }


    static ArrayList<ExtendedPeptide> digest_protein(String proteinSequence, DigestionParameters digestionParameters){
        IteratorFactory iteratorModifications = new IteratorFactory(new ArrayList<>());
        SequenceIterator sequenceIterator;
        try {
            sequenceIterator = iteratorModifications.getSequenceIterator(proteinSequence,
                    digestionParameters,
                    1.0,
                    proteinSequence.length()*1000);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        ExtendedPeptide extendedPeptide;
        ArrayList<ExtendedPeptide> peptides = new ArrayList<>();
        try{
            while ((extendedPeptide = sequenceIterator.getNextPeptide()) != null) {
                peptides.add(extendedPeptide);
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        return peptides;
    }

    public static void generate_protein_entrapment_database_from_multiple_species_data(String db, String out_file, String multiple_species_files, double k_fold) throws IOException {
        BufferedWriter dbWriter = new BufferedWriter(new FileWriter(out_file));

        DBGear dbGear = new DBGear();
        Enzyme enzyme = getEnzymeByIndex(CParameter.enzyme);
        HashSet<String> target_peptides = new HashSet<>();
        // read protein database
        int n_targets = 0;
        try {
            File dbFile = new File(db);
            FASTAFileReader reader = new FASTAFileReaderImpl(dbFile);
            FASTAElementIterator it = reader.getIterator();
            while (it.hasNext()) {
                FASTAElement el = it.next();
                el.setLineLength(1);
                String []headLine = el.getHeader().split("\\s+");
                String proID = headLine[0];
                n_targets++;
                String proSeq = el.getSequence();
                if(I2L){
                    proSeq = proSeq.replaceAll("I","L");
                }

                if(proSeq.contains("B")){
                    // 'N', 'D'
                    System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                    proSeq = proSeq.replaceAll("B", "N");
                }
                if(proSeq.contains("Z")){
                    // 'Q', 'E'
                    System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                    proSeq = proSeq.replaceAll("Z", "Q");
                }

                dbWriter.write(">"+el.getHeader()+"\n"+proSeq+"\n");

                if(no_shared_peptide_between_target_and_entrapment) {
                    HashSet<String> peps = dbGear.digest_protein(enzyme, proSeq);
                    target_peptides.addAll(peps);
                }

            }
            reader.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        System.out.println("The total number of proteins in target database:"+n_targets);

        String []fs = multiple_species_files.split(",");
        System.out.println("The total number of database files:"+fs.length);

        HashSet<String> entrapment_peptides = new HashSet<>();
        int n_entrapment = 0;
        int n_ignore = 0;
        // protein ID -> "sequence" -> protein sequence
        // protein ID -> "description" -> protein description
        HashMap<String, HashMap<String, String>> all_valid_entrapment_proteins = new HashMap<>();
        for(String f: fs){
            try {
                File dbFile = new File(f);
                FASTAFileReader reader = new FASTAFileReaderImpl(dbFile);
                FASTAElementIterator it = reader.getIterator();
                // Some uniprot proteins may have the same accession number.
                HashSet<String> uniprot_accs = new HashSet<>();
                int i = 0;
                while (it.hasNext()) {
                    FASTAElement el = it.next();
                    el.setLineLength(1);
                    i++;
                    String []headLine = el.getHeader().split("\\s+",2);
                    String proID = headLine[0];
                    String desc = headLine[1];
                    String proSeq = el.getSequence();
                    if(I2L){
                        proSeq = proSeq.replaceAll("I","L");
                    }

                    if(proSeq.contains("B")){
                        // 'N', 'D'
                        System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                        proSeq = proSeq.replaceAll("B", "N");
                    }
                    if(proSeq.contains("Z")){
                        // 'Q', 'E'
                        System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                        proSeq = proSeq.replaceAll("Z", "Q");
                    }

                    HashSet<String> peps = new HashSet<>();
                    if(no_shared_peptide_between_target_and_entrapment) {
                        peps = dbGear.digest_protein(enzyme, proSeq);
                        boolean shared = false;
                        for (String pep : peps) {
                            if (target_peptides.contains(pep)) {
                                System.out.println("Ignore entrapment protein " + proID + " due to shared peptide between target and entrapment:" +pep);
                                shared = true;
                                break;
                            }
                        }
                        if(shared){
                            n_ignore++;
                            continue;
                        }
                    }

                    n_entrapment++;
                    if(no_shared_peptide_between_target_and_entrapment) {
                        entrapment_peptides.addAll(peps);
                    }

                    if(for_diann && for_uniprot) {
                        String new_pro_ID = proID;
                        String new_desc = desc;
                        String [] acc_list = proID.split("\\|");
                        String [] desc_list = desc.split("\\s+");

                        if(acc_list.length==3) {

                            if (uniprot_accs.contains(acc_list[1])) {
                                System.err.println("Duplicate accession number: " + acc_list[1]);
                                acc_list[1] = acc_list[1] + "_i" + i;
                                proID = StringUtils.join(acc_list, "|");
                                System.err.println("Use accession number: " + acc_list[1]+", new ID:"+proID);
                            } else {
                                uniprot_accs.add(acc_list[1]);
                            }

                            new_pro_ID = acc_list[0] + "|" + acc_list[1]+"_p_target"+"|"+acc_list[2]+"_p_target";
                            boolean gn_detected = false;
                            for(int j=0;j< desc_list.length;j++){
                                if(desc_list[j].startsWith("GN=")){
                                    desc_list[j] = desc_list[j]+"_p_target";
                                    gn_detected = true;
                                    break;
                                }
                            }
                            if(gn_detected){
                                new_desc = StringUtils.join(desc_list," ");
                            }else{
                                System.err.println("Invalid protein ID: "+proID);
                                System.err.println("Invalid description: "+desc);
                                new_desc = StringUtils.join(desc_list," ")+" GN="+acc_list[2]+"_i"+i+"_p_target";
                                System.err.println("Use description: "+new_desc);
                            }
                        }else{
                            System.err.println("Invalid protein ID: "+proID);
                            System.exit(1);
                        }
                        all_valid_entrapment_proteins.put(new_pro_ID, new HashMap<>());
                        all_valid_entrapment_proteins.get(new_pro_ID).put("sequence", proSeq);
                        all_valid_entrapment_proteins.get(new_pro_ID).put("description", new_desc);
                        // dbWriter.write(">" + new_pro_ID+" "+new_desc+"\n" + proSeq + "\n");
                    }else {
                        String new_pro_ID = proID+"_p_target";
                        all_valid_entrapment_proteins.put(new_pro_ID, new HashMap<>());
                        all_valid_entrapment_proteins.get(new_pro_ID).put("sequence", proSeq);
                        all_valid_entrapment_proteins.get(new_pro_ID).put("description", desc);
                        // dbWriter.write(">"+proID+"_p_target " + desc + "\n" + proSeq + "\n");
                    }
                }
                reader.close();
                System.out.println("The total number of proteins in database "+f+": "+i);
            } catch (IOException e) {
                throw new RuntimeException(e);
            }


        }

        double ratio_entrapment_to_target = 1.0*all_valid_entrapment_proteins.size()/n_targets;
        int n_sample_entrapment = 0;
        // sample entrapment peptides
        Random global_random = new Random(global_random_seed);
        ArrayList<String> entrapment_protein_list = new ArrayList<>(all_valid_entrapment_proteins.keySet());
        Collections.shuffle(entrapment_protein_list, global_random);

        if(ratio_entrapment_to_target > k_fold){
            System.out.println("The ratio of entrapment proteins to target proteins is larger than "+k_fold+": "+all_valid_entrapment_proteins.size()+" vs "+n_targets);
            n_sample_entrapment = (int)(k_fold*n_targets);
        }
        int i_entrapment=0;
        for(String proID: entrapment_protein_list){
            i_entrapment++;
            String proSeq = all_valid_entrapment_proteins.get(proID).get("sequence");
            String desc = all_valid_entrapment_proteins.get(proID).get("description");
            dbWriter.write(">"+proID+" "+desc+"\n"+proSeq+"\n");
            if(i_entrapment==n_sample_entrapment && n_sample_entrapment>0){
                break;
            }
        }

        System.out.println("The total number of proteins in entrapment database:"+i_entrapment);
        double ratio = 1.0*i_entrapment/n_targets;
        System.out.println("# entrapment proteins / # target proteins: "+i_entrapment+"/"+n_targets + " = "+ratio);
        if(no_shared_peptide_between_target_and_entrapment){
            System.out.println("The total number of proteins ignored due to shared peptides between target and entrapment:"+n_ignore);
            System.out.println("Enzyme: "+enzyme.getName());
            System.out.println("Peptide length: "+CParameter.minPeptideLength+" - "+CParameter.maxPeptideLength);
            System.out.println("Max missed cleavages: "+CParameter.maxMissedCleavages);
            System.out.println("Clip N-term M: "+CParameter.clip_nTerm_M);
            double pep_ratio = 1.0*entrapment_peptides.size()/target_peptides.size();
            System.out.println("# entrapment peptides / # target peptides: "+entrapment_peptides.size()+"/"+target_peptides.size() + " = "+pep_ratio);
        }
        dbWriter.close();

    }


    public static void generate_protein_entrapment_database(String db, String out_file, int n_folds) throws IOException {

        BufferedWriter dbWriter = new BufferedWriter(new FileWriter(out_file));

        long startTime = System.currentTimeMillis();
        // read protein database
        File dbFile = new File(db);
        FASTAFileReader reader = new FASTAFileReaderImpl(dbFile);
        FASTAElementIterator it = reader.getIterator();

        // digest protein
        Enzyme enzyme = getEnzymeByIndex(CParameter.enzyme);
        System.out.println("Enzyme: "+enzyme.getName());
        // no missed cleavage
        CParameter.maxMissedCleavages = 0;
        DigestionParameters digestionParameters = getDigestionPreferences(enzyme.getName(), CParameter.maxMissedCleavages);

        ///////////////////////////////////////////////////////////
        // First round digestion
        // protein digestion
        int cpu;
        if (CParameter.cpu <= 0) {
            cpu = Runtime.getRuntime().availableProcessors();
        } else {
            cpu = CParameter.cpu;
        }
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(cpu);

        ConcurrentHashMap<String, HashSet<String>> pro2pepSeq = new ConcurrentHashMap<>(20000, 0.75F, cpu);
        HashSet<String> all_target_peptides = new HashSet<>();
        int num = 0;
        try {
            while (it.hasNext()) {
                FASTAElement el = it.next();
                el.setLineLength(1);
                String []headLine = el.getHeader().split("\\s+");
                String proID = headLine[0];
                num++;
                String proSeq = el.getSequence();
                if(I2L){
                    proSeq = proSeq.replaceAll("I","L");
                }
                pro2pepSeq.put(proID, new HashSet<>());
                if(proSeq.contains("B")){
                    // 'N', 'D'
                    System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                    proSeq = proSeq.replaceAll("B", "N");
                }
                if(proSeq.contains("Z")){
                    // 'Q', 'E'
                    System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                    proSeq = proSeq.replaceAll("Z", "Q");
                }
                fixedThreadPool.execute(new DigestProteinWorker4FDR(proID, proSeq, digestionParameters, pro2pepSeq));

            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        fixedThreadPool.shutdown();

        try {
            if(fixedThreadPool.awaitTermination(Long.MAX_VALUE, TimeUnit.HOURS)){
                System.out.println("Finished protein digestion for "+num+" proteins");
            }
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }

        for(String proID: pro2pepSeq.keySet()){
            all_target_peptides.addAll(pro2pepSeq.get(proID));
        }
        System.out.println("A total of "+all_target_peptides.size()+" peptides are generated from "+num+" proteins");
        reader.close();

        ///////////////////////////////////////////////////////////
        // Second round digestion: generate decoys for each protein
        // read protein database
        dbFile = new File(db);
        reader = new FASTAFileReaderImpl(dbFile);
        it = reader.getIterator();

        // The decoys have been generated so far.
        HashMap<String, ArrayList<String>> peptide2decoys = new HashMap<>();

        // add all target peptides
        HashSet<String> target_decoy_peptides = new HashSet<>(all_target_peptides);
        HashSet<String> empty_target_decoy_peptides = new HashSet<>();

        // Some uniprot proteins may have the same accession number.
        HashSet<String> uniprot_accs = new HashSet<>();

        boolean fix_c = false;
        boolean fix_n = false;
        if(fix_nc_aa == Fix_NC.N){
            fix_n = true;
            System.out.println("Fix N terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.C){
            fix_c = true;
            System.out.println("Fix C terminal amino acid");
        }else if(fix_nc_aa == Fix_NC.NC){
            fix_n = true;
            fix_c = true;
            System.out.println("Fix both C and N terminal amino acids");
        }else{
            System.err.println("Invalid fix_nc_aa option: "+fix_nc_aa);
            System.exit(1);
        }

        // for each protein, generate one decoy protein or multiple decoy proteins
        int n_r_pro = n_folds;
        if(add_decoy){
            // n_fold = 1, 3
            // n_fold = 2, 5
            n_r_pro = 2*n_folds+1;
        }

        int i = 0;
        Random global_random = new Random(global_random_seed);
        int checking_for_duplicates_then_random_n = 0;
        int n_total_peptides_to_random_peptides = 0;
        while (it.hasNext()) {
            // for each protein, generate one or multiple decoy/entrapment proteins
            FASTAElement el = it.next();
            el.setLineLength(1);
            i++;
            String []headLine = el.getHeader().split("\\s+",2);
            String proID = headLine[0];
            String desc = headLine[1];
            String proSeq = el.getSequence();
            if(reverse_target_protein_for_entrapment_protein_generation){
                proSeq = StringUtils.reverse(proSeq);
            }
            if(I2L){
                proSeq = proSeq.replaceAll("I","L");
            }
            if(proSeq.contains("B")){
                // 'N', 'D'
                System.out.println("Amino acid B is replaced with N:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("B", "N");
            }
            if(proSeq.contains("Z")){
                // 'Q', 'E'
                System.out.println("Amino acid Z is replaced with Q:"+proID+"\n"+proSeq);
                proSeq = proSeq.replaceAll("Z", "Q");
            }
            ArrayList<ExtendedPeptide> digested_peptides = digest_protein(proSeq,digestionParameters);
            // This is used to generate entrapment proteins
            ArrayList<ArrayList<String>> decoy_peptides = new ArrayList<>(digested_peptides.size());
            // for each peptide, generate decoy peptides
            for(ExtendedPeptide extendedPeptide: digested_peptides){
                String pep = extendedPeptide.peptide.getSequence();
                ArrayList<String> rnd_peptides = new ArrayList<>();
                if(!peptide2decoys.containsKey(extendedPeptide.peptide.getSequence())){
                    // for each peptide, generate one decoy peptide or multiple decoy peptides
                    if(pep.length()<=1){
                        // don't need to generate decoy peptides.
                        rnd_peptides.add(pep);
                    }else {
                        try {
                            n_total_peptides_to_random_peptides++;
                            if(generate_entrapment_protein_for_each_target_protein_independently) {
                                if(random_peptide_generation_method == 0) {
                                    // 0
                                    if (fix_random_seed) {
                                        rnd_peptides = generateShufflePeptidesFast(pep, n_r_pro, fix_c, fix_n, empty_target_decoy_peptides, new Random(global_random_seed), n_max_try_decoy_peptide_generation);
                                    }else{
                                        rnd_peptides = generateShufflePeptidesFast(pep, n_r_pro, fix_c, fix_n, empty_target_decoy_peptides, global_random, n_max_try_decoy_peptide_generation);
                                    }
                                }else {
                                    // 1
                                    if (fix_random_seed) {
                                        rnd_peptides = generateShufflePeptidesFastSwap(pep, n_r_pro, fix_c, fix_n, empty_target_decoy_peptides, new Random(global_random_seed), n_max_try_decoy_peptide_generation);
                                    }else{
                                        rnd_peptides = generateShufflePeptidesFastSwap(pep, n_r_pro, fix_c, fix_n, empty_target_decoy_peptides, global_random, n_max_try_decoy_peptide_generation);
                                    }
                                }
                            }else{
                                if(random_peptide_generation_method == 0) {
                                    // 0
                                    if(fix_random_seed) {
                                        rnd_peptides = generateShufflePeptidesFast(pep, n_r_pro, fix_c, fix_n, target_decoy_peptides, new Random(global_random_seed), n_max_try_decoy_peptide_generation);
                                    }else{
                                        rnd_peptides = generateShufflePeptidesFast(pep, n_r_pro, fix_c, fix_n, target_decoy_peptides, global_random, n_max_try_decoy_peptide_generation);
                                    }
                                }else {
                                    if(fix_random_seed) {
                                        rnd_peptides = generateShufflePeptidesFastSwap(pep, n_r_pro, fix_c, fix_n, target_decoy_peptides, new Random(global_random_seed), n_max_try_decoy_peptide_generation);
                                    }else{
                                        rnd_peptides = generateShufflePeptidesFastSwap(pep, n_r_pro, fix_c, fix_n, target_decoy_peptides, global_random, n_max_try_decoy_peptide_generation);
                                    }
                                }
                            }
                        } catch (Exception e) {
                            System.err.println("Error: " + pep);
                            System.err.println("Error: " + e.getMessage());
                            System.exit(1);
                        }
                        if(rnd_peptides.isEmpty()){
                            if(checking_for_duplicates_then_random){
                                if (fix_random_seed) {
                                    rnd_peptides = generateShufflePeptidesFastSwap(pep, n_r_pro, fix_c, fix_n, empty_target_decoy_peptides, new Random(global_random_seed), n_max_try_decoy_peptide_generation);
                                }else{
                                    rnd_peptides = generateShufflePeptidesFastSwap(pep, n_r_pro, fix_c, fix_n, empty_target_decoy_peptides, global_random, n_max_try_decoy_peptide_generation);
                                }
                                if(rnd_peptides.isEmpty()) {
                                    rnd_peptides.add(pep);
                                    System.out.println("No valid random peptides are generated for peptide: " + pep);
                                }else{
                                    checking_for_duplicates_then_random_n++;
                                }
                            }else {
                                rnd_peptides.add(pep);
                            }
                        }
                    }

                    if(rnd_peptides.size()<n_r_pro){
                        // need to sample peptides from the existing decoy peptides
                        int n_req = n_r_pro - rnd_peptides.size();
                        // generate n_req random numbers with range between 0 and rnd_peptides.size()-1
                        ArrayList<Integer> rnd_indices = new ArrayList<>();
                        for(int j=0;j<n_req;j++){
                            rnd_indices.add(global_random.nextInt(rnd_peptides.size()));
                        }
                        for(int j=0;j<n_req;j++){
                            int r_i = rnd_indices.get(j);
                            rnd_peptides.add(rnd_peptides.get(r_i));
                        }
                    }

                    if(shuffle_order_of_generated_random_peptides && rnd_peptides.size()>=2){
                        Collections.shuffle(rnd_peptides, global_random);
                    }

                    peptide2decoys.put(pep,rnd_peptides);
                }else{
                    // Use existing decoy peptides;
                    rnd_peptides = peptide2decoys.get(pep);
                }
                // System.out.println(extendedPeptide.peptide.getSequence());
                // System.out.println(rnd_peptides.get(0));
                // System.out.println();
                decoy_peptides.add(rnd_peptides);
                // save all target peptides and the decoy peptides generated so far.
                target_decoy_peptides.addAll(rnd_peptides);

            }

            if(for_diann && for_uniprot) {
                String [] acc_list = proID.split("\\|");
                if (uniprot_accs.contains(acc_list[1])) {
                    System.err.println("Duplicate accession number: " + acc_list[1]);
                    acc_list[1] = acc_list[1] + "_i" + i;
                    proID = StringUtils.join(acc_list, "|");
                    System.err.println("Use accession number: " + acc_list[1]+", new ID:"+proID);
                } else {
                    uniprot_accs.add(acc_list[1]);
                }
            }

            dbWriter.write(">"+proID+" "+desc+"\n"+proSeq+"\n");
            // System.out.println("target peptides:"+digested_peptides.size());
            // System.out.println("decoy peptides: "+decoy_peptides.size());

            // for entrapment proteins
            int seed_j = 0;
            HashMap<Integer,Random> i2rand = new HashMap<>();
            for(int n=0;n<n_folds;n++){
                StringBuilder decoy_protein = new StringBuilder();
                int jj = 0;
                for (ArrayList<String> decoyPeptide : decoy_peptides) {
                    jj++;
                    if (decoyPeptide.size() >= (n + 1)) {
                        //System.out.println(n+"\t"+decoyPeptide.get(n));
                        decoy_protein.append(decoyPeptide.get(n));
                    } else {
                        if(!i2rand.containsKey(jj)){
                            Random rand = new Random(jj);
                            i2rand.put(jj,rand);
                        }
                        int r_p_i = i2rand.get(jj).nextInt(decoyPeptide.size());
                        // System.out.println(jj+"\t"+decoyPeptide.get(0));
                        // randomly select one from decoyPeptide
                        String r_p = decoyPeptide.get(r_p_i);
                        decoy_protein.append(r_p);
                        //decoy_protein.append(decoyPeptide.get(0));
                    }
                }
                if(decoy_protein.length()!=proSeq.length()){
                    System.err.println("The decoy protein length is not the same with the target protein length: "+decoy_protein.length()+"\t"+proSeq.length());
                    System.err.println("Decoy protein:"+decoy_protein);
                    System.err.println("Target protein:"+proSeq);
                }

                if(for_diann && for_uniprot) {

                    String n_fold_label = "_"+n;
                    if(n_folds == 1){
                        n_fold_label = "";
                    }
                    String new_pro_ID = proID;
                    String new_desc = desc;
                    String [] acc_list = proID.split("\\|");
                    String [] desc_list = desc.split("\\s+");
                    if(acc_list.length==3) {
                        if(entrapment_label_position == Label_Position.end) {
                            // new_pro_ID = acc_list[0] + "|" + acc_list[1] + n_fold_label + "_p_target" + "|" + acc_list[2] + n_fold_label + "_p_target";
                            new_pro_ID = acc_list[0] + "|" + acc_list[1] + n_fold_label + entrapment_label + "|" + acc_list[2] + n_fold_label + entrapment_label;
                        }else{
                            new_pro_ID = acc_list[0] + "|" + entrapment_label + acc_list[1] + n_fold_label + "|" + entrapment_label + acc_list[2] + n_fold_label;
                        }
                        boolean gn_detected = false;
                        for(int j=0;j< desc_list.length;j++){
                            if(desc_list[j].startsWith("GN=")){
                                if(entrapment_label_position == Label_Position.end) {
                                    desc_list[j] = desc_list[j] + n_fold_label + entrapment_label;
                                }else{
                                    desc_list[j] =  desc_list[j].replaceFirst("GN=", "GN="+entrapment_label) + n_fold_label;
                                }
                                gn_detected = true;
                                break;
                            }
                        }
                        if(gn_detected){
                            new_desc = StringUtils.join(desc_list," ");
                        }else{
                            System.err.println("Invalid protein ID: "+proID);
                            System.err.println("Invalid description: "+desc);
                            if(entrapment_label_position == Label_Position.end) {
                                new_desc = StringUtils.join(desc_list, " ") + " GN=" + acc_list[2] + "_i" + i + n_fold_label + entrapment_label;
                            }else{
                                new_desc = StringUtils.join(desc_list, " ") + " GN=" + entrapment_label + acc_list[2] + "_i" + i + n_fold_label;
                            }
                            System.err.println("Use description: "+new_desc);
                        }
                    }else{
                        System.err.println("Invalid protein ID: "+proID);
                        System.exit(1);
                    }
                    dbWriter.write(">" + new_pro_ID+" "+new_desc+"\n" + decoy_protein + "\n");

                }else{
                    if (n_folds == 1) {
                        if(entrapment_label_position == Label_Position.end) {
                            dbWriter.write(">" + proID + entrapment_label + "\n" + decoy_protein + "\n");
                        }else{
                            dbWriter.write(">" + entrapment_label + proID + "\n" + decoy_protein + "\n");
                        }
                    } else {
                        if(entrapment_label_position == Label_Position.end) {
                            dbWriter.write(">" + proID + "_" + n + entrapment_label  + "\n" + decoy_protein + "\n");
                        }else{
                            dbWriter.write(">" + entrapment_label + proID + "_" + n + "\n" + decoy_protein + "\n");
                        }
                    }
                }

            }

            // for decoy proteins
            if(add_decoy){
                int n_decoy = n_r_pro - n_folds;
                i2rand = new HashMap<>();
                for(int n=0;n<n_decoy;n++) {
                // for(int n=0;n<n_folds;n++){
                    StringBuilder decoy_protein = new StringBuilder();
                    for (ArrayList<String> decoyPeptide : decoy_peptides) {
                        if(decoyPeptide.size()!=n_r_pro){
                            System.err.println("Error: the number of random peptides required: "+n_r_pro+", but only " +decoyPeptide.size()+ " random peptides generated!");
                            System.exit(1);
                        }
                        decoy_protein.append(decoyPeptide.get(n+n_folds));
                    }
                    if(decoy_protein.length()!=proSeq.length()){
                        System.err.println("The decoy protein length is not the same with the target protein length: "+decoy_protein.length()+"\t"+proSeq.length());
                        System.err.println("Decoy protein:"+decoy_protein);
                        System.err.println("Target protein:"+proSeq);
                    }

                    if(for_diann && for_uniprot) {

                        String n_fold_label = "_"+n;
                        if(n_folds == 1){
                            n_fold_label = "";
                        }
                        String new_pro_ID = proID;
                        String new_desc = desc;
                        String [] acc_list = proID.split("\\|");
                        String [] desc_list = desc.split("\\s+");
                        if(acc_list.length==3) {
                            if(decoy_label_position == Label_Position.end) {
                                // new_pro_ID = acc_list[0] + "|" + acc_list[1] + n_fold_label + "_p_target" + "|" + acc_list[2] + n_fold_label + "_p_target";
                                if(n==0){
                                    // for target protein
                                    new_pro_ID = acc_list[0] + "|" + acc_list[1] + n_fold_label + decoy_label + "|" + acc_list[2] + n_fold_label + decoy_label;
                                }else {
                                    // for entrapment protein
                                    if(entrapment_label_position == Label_Position.end) {
                                        new_pro_ID = acc_list[0] + "|" + acc_list[1] + n_fold_label +entrapment_label+ decoy_label + "|" + acc_list[2] + n_fold_label +entrapment_label+ decoy_label;
                                    }else{
                                        new_pro_ID = acc_list[0] + "|" + entrapment_label + acc_list[1] + n_fold_label + decoy_label + "|" + entrapment_label + acc_list[2] + n_fold_label + decoy_label;
                                    }
                                }
                            }else{
                                if(n==0) {
                                    new_pro_ID = acc_list[0] + "|" + decoy_label + acc_list[1] + n_fold_label + "|" + decoy_label + acc_list[2] + n_fold_label;
                                }else{
                                    if(entrapment_label_position == Label_Position.end) {
                                        new_pro_ID = acc_list[0] + "|" + decoy_label + acc_list[1] + n_fold_label + entrapment_label + "|" + decoy_label + acc_list[2] + n_fold_label + entrapment_label;
                                    }else{
                                        new_pro_ID = acc_list[0] + "|" + decoy_label + entrapment_label + acc_list[1] + n_fold_label + "|" + decoy_label + entrapment_label+ acc_list[2] + n_fold_label;
                                    }
                                }
                            }
                            boolean gn_detected = false;
                            for(int j=0;j< desc_list.length;j++){
                                if(desc_list[j].startsWith("GN=")){
                                    if(decoy_label_position == Label_Position.end) {
                                        if(n==0){
                                            // for target protein
                                            desc_list[j] = desc_list[j] + n_fold_label + decoy_label;
                                        }else{
                                            // for entrapment protein
                                            if(entrapment_label_position == Label_Position.end) {
                                                desc_list[j] = desc_list[j] + n_fold_label + entrapment_label + decoy_label;
                                            }else{
                                                desc_list[j] =  desc_list[j].replaceFirst("GN=","GN="+entrapment_label) + n_fold_label + decoy_label;
                                            }
                                        }

                                    }else{
                                        if(n==0) {
                                            desc_list[j] = desc_list[j].replaceFirst("GN=", "GN=" + decoy_label) + n_fold_label;
                                        }else{
                                            if(entrapment_label_position == Label_Position.end) {
                                                desc_list[j] = desc_list[j].replaceFirst("GN=", "GN=" + decoy_label) + n_fold_label + entrapment_label;
                                            }else{
                                                desc_list[j] = desc_list[j].replaceFirst("GN=", "GN=" + decoy_label + entrapment_label) + n_fold_label;
                                            }
                                        }
                                    }
                                    gn_detected = true;
                                    break;
                                }
                            }
                            if(gn_detected){
                                new_desc = StringUtils.join(desc_list," ");
                            }else{
                                System.err.println("Invalid protein ID: "+proID);
                                System.err.println("Invalid description: "+desc);
                                if(decoy_label_position == Label_Position.end) {
                                    if(n==0){
                                        new_desc = StringUtils.join(desc_list, " ") + " GN=" + acc_list[2] + "_i" + i + n_fold_label + decoy_label;
                                    }else{
                                        if(entrapment_label_position == Label_Position.end) {
                                            new_desc = StringUtils.join(desc_list, " ") + " GN=" + acc_list[2] + "_i" + i + n_fold_label + entrapment_label + decoy_label;
                                        }else{
                                            new_desc = StringUtils.join(desc_list, " ") + " GN=" + entrapment_label + acc_list[2] + "_i" + i + n_fold_label + decoy_label;
                                        }
                                    }
                                }else{
                                    if(entrapment_label_position == Label_Position.end) {
                                        new_desc = StringUtils.join(desc_list, " ") + " GN=" + decoy_label + acc_list[2] + "_i" + i + n_fold_label + entrapment_label;
                                    }else{
                                        new_desc = StringUtils.join(desc_list, " ") + " GN=" + decoy_label + entrapment_label+ acc_list[2] + "_i" + i + n_fold_label;
                                    }
                                }
                                System.err.println("Use description: "+new_desc);
                            }
                        }else{
                            System.err.println("Invalid protein ID: "+proID);
                            System.exit(1);
                        }
                        dbWriter.write(">" + new_pro_ID+" "+new_desc+"\n" + decoy_protein + "\n");

                    }else{
                        if (n_folds == 1) {
                            if(decoy_label_position == Label_Position.end) {
                                if(n==0) {
                                    dbWriter.write(">" + proID + decoy_label + "\n" + decoy_protein + "\n");
                                }else{
                                    if(entrapment_label_position == Label_Position.end) {
                                        dbWriter.write(">" + proID + entrapment_label + decoy_label + "\n" + decoy_protein + "\n");
                                    }else{
                                        dbWriter.write(">" + entrapment_label + proID + decoy_label + "\n" + decoy_protein + "\n");
                                    }
                                }
                            }else{
                                if(n==0) {
                                    dbWriter.write(">" + decoy_label + proID + "\n" + decoy_protein + "\n");
                                }else{
                                    if(entrapment_label_position == Label_Position.end) {
                                        dbWriter.write(">" + decoy_label + proID + entrapment_label + "\n" + decoy_protein + "\n");
                                    }else{
                                        dbWriter.write(">" + decoy_label +entrapment_label+ proID + "\n" + decoy_protein + "\n");
                                    }
                                }
                            }
                        } else {
                            if(decoy_label_position == Label_Position.end) {
                                if(n==0) {
                                    dbWriter.write(">" + proID + "_" + n + decoy_label + "\n" + decoy_protein + "\n");
                                }else{
                                    if(entrapment_label_position == Label_Position.end) {
                                        dbWriter.write(">" + proID + "_" + n + entrapment_label + decoy_label + "\n" + decoy_protein + "\n");
                                    }else{
                                        dbWriter.write(">" + entrapment_label + proID + "_" + n  + decoy_label + "\n" + decoy_protein + "\n");
                                    }
                                }
                            }else{
                                if(n==0) {
                                    dbWriter.write(">" + decoy_label + proID + "_" + n + "\n" + decoy_protein + "\n");
                                }else{
                                    if(entrapment_label_position == Label_Position.end) {
                                        dbWriter.write(">" + decoy_label + proID + "_" + n +entrapment_label+ "\n" + decoy_protein + "\n");
                                    }else{
                                        dbWriter.write(">" + decoy_label + entrapment_label + proID + "_" + n + "\n" + decoy_protein + "\n");
                                    }
                                }
                            }
                        }
                    }

                }
            }

        }
        reader.close();
        dbWriter.close();
        long bTime = System.currentTimeMillis();

        if(checking_for_duplicates_then_random){
            System.out.println("The number of peptides that are checked for duplicates then randomly selected: "+checking_for_duplicates_then_random_n);
        }
        System.out.println("The total number of target peptides used to generate random peptides: "+n_total_peptides_to_random_peptides);

        Cloger.getInstance().logger.info("Time used for protein digestion:" + (bTime - startTime) / 1000 + " s.");

    }


    public void calc_fdp_fast(String psm_file, String pep_file, String target_col_name, String out_file){
        HashMap<String,Integer> col2index = get_column_names(psm_file,"\t");
        CsvReadOptions.Builder builder = CsvReadOptions.builder(psm_file)
                .columnTypesPartial(Collections.singletonMap("q_value", ColumnType.DOUBLE))
                .separator('\t')
                .header(true);
        CsvReadOptions options = builder.build();
        Table psm_table = Table.read().usingOptions(options);
        // sort the table based on q_value and a score if available
        if(!score_column_name.equalsIgnoreCase("-")) {
            System.out.println("Use both "+this.q_value_column_name+" and "+this.score_column_name + " for ranking");
            String score_rank = this.score_higher_is_better ? "-" + this.score_column_name : this.score_column_name;
            // if column name starts with "-", sort that column descending (max to min) otherwise sort ascending (min to max)
            psm_table = psm_table.sortOn(this.q_value_column_name,score_rank);
        }else{
            // min to max
            psm_table = psm_table.sortOn(this.q_value_column_name);
        }



        HashMap<String,String> target2label = new HashMap<>();
        if(this.fdp_level.equals(FDRType.precursor) ||
                this.fdp_level.equals(FDRType.psm) ||
                this.fdp_level.equals(FDRType.peptide)){
            HashSet<String> peptides = get_all_peptides(psm_file,"peptide");
            target2label = get_peptide_type(pep_file,peptides);

            if(this.fdp_level.equals(FDRType.precursor) || this.fdp_level.equals(FDRType.peptide)){
                peptidePair.load(pep_file,peptides);
            }
        }else{
            HashSet<String> proteins = get_all_proteins(psm_file,"protein");
            File PEP_FILE = new File(pep_file);
            if(PEP_FILE.isFile()) {
                target2label = get_peptide_type(pep_file, proteins);
            }
        }
        // FDP calculation
        DoubleColumn fdp_column = DoubleColumn.create("combined_fdp", psm_table.rowCount());
        IntColumn n_targets_column = IntColumn.create("n_t", psm_table.rowCount());
        IntColumn n_entrapment_targets_column = IntColumn.create("n_p", psm_table.rowCount());

        DoubleColumn fdp_1b_column = DoubleColumn.create("paired_fdp", psm_table.rowCount());
        IntColumn n_p_t_s_column = IntColumn.create("n_p_t_s", psm_table.rowCount());
        IntColumn n_p_s_t_column = IntColumn.create("n_p_s_t", psm_table.rowCount());

        DoubleColumn fdp_lower_bound_column = DoubleColumn.create("lower_bound_fdp", psm_table.rowCount());


        int cpu = Runtime.getRuntime().availableProcessors();
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(cpu);
        ConcurrentHashMap<Integer, HashMap<String, Double>> res = new ConcurrentHashMap<>(psm_table.rowCount());

        FDPCalc.psm_table = psm_table;
        FDPCalc.fdp_level = this.fdp_level;
        FDPCalc.target_col_name = target_col_name;
        FDPCalc.target2label = target2label;
        FDPCalc.peptidePair = peptidePair;

        HashMap<Integer, PMatch> psm_map = new HashMap<>(psm_table.rowCount());
        HashMap<Double,Integer> fdr2index = new HashMap<>();
        for(int i=0;i<psm_table.rowCount();i++){
            PMatch pmatch = new PMatch();
            if(fdp_level.equals(FDRType.protein)){
                // pmatch.protein = psm_table.row(i).getString("protein");
                // pmatch.protein = PEntrapment.format_pg(psm_table.row(i).getString("protein"),";","p_target",pick_one_protein_method);
                pmatch.protein = PEntrapment.format_pg(psm_table.row(i).getString("protein"),";",entrapment_label,pick_one_protein_method);
            }else if(fdp_level.equals(FDRType.peptide)){
                pmatch.peptide = psm_table.row(i).getString("peptide");
            }else if(fdp_level.equals(FDRType.precursor)) {
                pmatch.peptide = psm_table.row(i).getString("peptide");
                pmatch.charge = psm_table.row(i).getInt("charge");
                pmatch.mod_peptide = psm_table.row(i).getString("mod_peptide");
            }else{
                System.err.println("FDP level is not supported: "+fdp_level);
                System.exit(1);
            }
            psm_map.put(i,pmatch);
            // psm_table is already sorted by q_value from min to max
            double fdr = psm_table.row(i).getDouble("q_value");
            fdr2index.put(fdr,i);
        }

        System.out.println("The number of unique FDR values: "+fdr2index.size());

        FDPCalc.psm_map = psm_map;

        //for(int i=0;i<psm_table.rowCount();i++){
        for(int i: fdr2index.values()){
            // if(i % 2000 == 0){
            //    System.out.println("Processing "+i+" matches");
            //}
            res.put(i, new HashMap<>());
            fixedThreadPool.execute(new FDPCalc(i,res));
        }

        fixedThreadPool.shutdown();

        try {
            fixedThreadPool.awaitTermination(Long.MAX_VALUE, TimeUnit.HOURS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int k;
        for(int i=0;i<psm_table.rowCount();i++){
            double fdr = psm_table.row(i).getDouble("q_value");
            k = fdr2index.get(fdr);
            double fdp = res.get(k).get("fdp");
            fdp_column.set(i, fdp);
            n_targets_column.set(i, res.get(k).get("n_targets").intValue());
            n_entrapment_targets_column.set(i, res.get(k).get("n_entrapment_targets").intValue());

            // ( N_{p>s} + 2 * N_{p>t>s} + N_{p>s>t} ) / (N_{p>s} + N_{t>s}).
            double fdp_1b = res.get(k).get("paired_fdp");
            fdp_1b_column.set(i, fdp_1b);

            double low_bound_fdp = res.get(k).get("low_bound_fdp");
            fdp_lower_bound_column.set(i, low_bound_fdp);

            n_p_t_s_column.set(i, res.get(k).get("n_p_t_s").intValue());
            n_p_s_t_column.set(i, res.get(k).get("n_p_s_t").intValue());
        }

        // q-value
        if(fdp_qvalue) {
            double cur_min_fdp = 1;
            for (int i = psm_table.rowCount() - 1; i >= 0; i--) {
                double min_fdr = Math.min(cur_min_fdp, fdp_column.get(i));
                fdp_column.set(i, min_fdr);
                cur_min_fdp = min_fdr;
            }
        }
        if(psm_table.columnNames().contains("combined_fdp")){
            psm_table.removeColumns("combined_fdp");
        }
        psm_table.addColumns(fdp_column);
        psm_table.addColumns(n_targets_column);
        psm_table.addColumns(n_entrapment_targets_column);

        if(fdp_qvalue) {
            double cur_min_fdp = 1;
            for (int i = psm_table.rowCount() - 1; i >= 0; i--) {
                double min_fdr = Math.min(cur_min_fdp, fdp_1b_column.get(i));
                fdp_1b_column.set(i, min_fdr);
                cur_min_fdp = min_fdr;
            }
        }
        if (psm_table.columnNames().contains("paired_fdp")) {
            psm_table.removeColumns("paired_fdp");
        }
        psm_table.addColumns(fdp_1b_column);
        psm_table.addColumns(n_p_t_s_column);
        psm_table.addColumns(n_p_s_t_column);
        psm_table.addColumns(fdp_lower_bound_column);

        psm_table.write().csv(out_file);
    }


    public void calc_fdp_fast_kfold(String psm_file, String pep_file, String target_col_name, String out_file) throws IOException {

        // remove invalid peptide
        if(this.fdp_level.equals(FDRType.precursor) ||
                this.fdp_level.equals(FDRType.psm) ||
                this.fdp_level.equals(FDRType.peptide)) {
            HashSet<String> peptides = get_all_peptides(psm_file,"peptide");
            HashMap<String,String> target2label = get_peptide_type(pep_file, peptides);
            HashSet<String> invalid_peptides = new HashSet<>();
            for(String pep: peptides){
                if(!target2label.containsKey(pep)){
                    invalid_peptides.add(pep);
                }
            }
            if(!invalid_peptides.isEmpty()){
                System.err.println("Invalid peptides found:"+invalid_peptides.size());
                String new_psm_file = psm_file + ".remove_invalid_peptides";
                BufferedWriter npWriter = new BufferedWriter(new FileWriter(new_psm_file));

                HashMap<String,Integer> col2index = get_column_names(psm_file,"\t");
                BufferedReader pReader = new BufferedReader(new FileReader(psm_file));
                npWriter.write(pReader.readLine().trim()+"\n");
                String line;
                while ((line = pReader.readLine()) != null) {
                    String [] items = line.split("\t");
                    String peptide = items[col2index.get("peptide")];
                    if(invalid_peptides.contains(peptide)){
                       System.err.println("Remove: "+line);
                    }else{
                        npWriter.write(line.trim()+"\n");
                    }
                }
                pReader.close();
                npWriter.close();
                psm_file = new_psm_file;
                System.out.println("Use new file:"+new_psm_file);
            }
        }
        HashMap<String,Integer> col2index = get_column_names(psm_file,"\t");
        CsvReadOptions.Builder builder = CsvReadOptions.builder(psm_file)
                .columnTypesPartial(Collections.singletonMap("q_value", ColumnType.DOUBLE))
                .separator('\t')
                .header(true);
        CsvReadOptions options = builder.build();
        Table psm_table = Table.read().usingOptions(options);
        // sort the table based on q_value and a score if available
        if(!score_column_name.equalsIgnoreCase("-")) {
            System.out.println("Use both "+this.q_value_column_name+" and "+this.score_column_name + " for ranking");
            String score_rank = this.score_higher_is_better ? "-" + this.score_column_name : this.score_column_name;
            // if column name starts with "-", sort that column descending (max to min) otherwise sort ascending (min to max)
            psm_table = psm_table.sortOn(this.q_value_column_name,score_rank);
        }else{
            // min to max
            psm_table = psm_table.sortOn(this.q_value_column_name);
        }



        HashMap<String,String> target2label = new HashMap<>();
        if(this.fdp_level.equals(FDRType.precursor) ||
                this.fdp_level.equals(FDRType.psm) ||
                this.fdp_level.equals(FDRType.peptide)){
            HashSet<String> peptides = get_all_peptides(psm_file,"peptide");
            target2label = get_peptide_type(pep_file,peptides);

            if(this.fdp_level.equals(FDRType.precursor) || this.fdp_level.equals(FDRType.peptide)){
                //peptidePair.load(pep_file,peptides);
                peptidePair.load(pep_file,peptides,n_fold);
            }
        }else{
            HashSet<String> proteins = get_all_proteins(psm_file,"protein");
            File PEP_FILE = new File(pep_file);
            if(PEP_FILE.isFile()) {
                target2label = get_peptide_type(pep_file, proteins);
            }
        }
        // FDP calculation
        DoubleColumn fdp_column = DoubleColumn.create("combined_fdp", psm_table.rowCount());
        IntColumn n_targets_column = IntColumn.create("n_t", psm_table.rowCount());
        IntColumn n_entrapment_targets_column = IntColumn.create("n_p", psm_table.rowCount());

        DoubleColumn fdp_1b_column = DoubleColumn.create("paired_fdp", psm_table.rowCount());
        IntColumn n_p_t_s_column = IntColumn.create("n_p_t_s", psm_table.rowCount());
        IntColumn n_p_s_t_column = IntColumn.create("n_p_s_t", psm_table.rowCount());
        IntColumn n_vt_column = IntColumn.create("vt", psm_table.rowCount());

        DoubleColumn fdp_lower_bound_column = DoubleColumn.create("lower_bound_fdp", psm_table.rowCount());

        int cpu = Runtime.getRuntime().availableProcessors();
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(cpu);
        ConcurrentHashMap<Integer, HashMap<String, Double>> res = new ConcurrentHashMap<>(psm_table.rowCount());

        // The original input identification table
        FDPCalc.psm_table = psm_table;
        // protein, peptide or precursor level FDR control evaluation
        FDPCalc.fdp_level = this.fdp_level;
        //
        FDPCalc.target_col_name = target_col_name;
        //
        FDPCalc.target2label = target2label;
        FDPCalc.peptidePair = peptidePair;

        HashMap<Integer, PMatch> psm_map = new HashMap<>(psm_table.rowCount());
        HashMap<Double,Integer> fdr2index = new HashMap<>();


        // step 1
        // if it is precursor, variable modification is not supported yet.
        // Entrapment list, key: target peptide or protein or precursor (peptide+charge); value: entrapment matches
        HashMap<String, PEntrapment> target2entrapment = new HashMap<>();
        // Store all matches: key=id, value=PMatch
        // "id" is a unique ID for each match
        // Precursor level: peptide + modification +charge or peptide + charge;
        // Peptide level: peptide;
        // Protein level: protein
        HashMap<String, PMatch> id2PMatch = new HashMap<>();

        // grouping entrapment matches based on their paired target matches if available
        for(int i=0;i<psm_table.rowCount();i++){
            PMatch pmatch = new PMatch();
            boolean is_entrapment = false;
            if(fdp_level.equals(FDRType.protein)){
                //pmatch.protein = PEntrapment.format_pg(psm_table.row(i).getString("protein"),";","p_target",pick_one_protein_method);
                pmatch.protein = PEntrapment.format_pg(psm_table.row(i).getString("protein"),";",entrapment_label,pick_one_protein_method);
                pmatch.id = pmatch.protein;
                // is_entrapment = pmatch.id.endsWith("p_target");
                is_entrapment = pmatch.id.endsWith(entrapment_label) || pmatch.id.startsWith(entrapment_label);
            }else if(fdp_level.equals(FDRType.peptide)){
                // Variable modification should not be used if it is not real unique peptide sequence level.
                pmatch.peptide = psm_table.row(i).getString("peptide");
                pmatch.id = psm_table.row(i).getString("peptide");
                if(target2label.containsKey(pmatch.peptide)){
                    is_entrapment = target2label.get(pmatch.peptide).equals("p_target");
                }else{
                    System.err.println("The peptide is not present in the peptide list: "+pmatch.peptide);
                    System.exit(1);
                }
            }else if(fdp_level.equals(FDRType.precursor)) {
                // Don't use variable modification in the search for the current version.
                // So each precursor is a matched peptide sequence with charge state.
                pmatch.peptide = psm_table.row(i).getString("peptide");
                pmatch.charge = psm_table.row(i).getInt("charge");
                pmatch.mod_peptide = psm_table.row(i).getString("mod_peptide");
                // id: peptide charge
                pmatch.id = psm_table.row(i).getString("peptide")+ psm_table.row(i).getInt("charge");
                // psm_table.row(i).getString("mod_peptide").length()+"|"+
                is_entrapment = target2label.get(pmatch.peptide).equals("p_target");
            }else{
                System.err.println("FDP level is not supported: "+fdp_level);
                System.exit(1);
            }
            pmatch.is_entrapment = is_entrapment;
            psm_map.put(i,pmatch);

            pmatch.rank_score = 1.0/(i+1);
            pmatch.score_higher_is_better = true;

            id2PMatch.put(pmatch.id,pmatch);

            if(pmatch.is_entrapment){
                String target = "";
                if(fdp_level.equals(FDRType.protein)){
                    // target = PEntrapment.get_target_protein_by_entrapment_protein(pmatch.id, n_fold, "_p_target", ";");
                    target = PEntrapment.get_target_protein_by_entrapment_protein(pmatch.id, n_fold, entrapment_label, ";");
                }else if(fdp_level.equals(FDRType.peptide)){
                    target = peptidePair.get_paired_target_peptide(pmatch.peptide);
                }else if(fdp_level.equals(FDRType.precursor)) {
                    target = peptidePair.get_paired_target_peptide(pmatch.peptide)+pmatch.charge;
                }else{
                    System.err.println("FDP level is not supported: "+fdp_level);
                    System.exit(1);
                }
                if(target2entrapment.containsKey(target)){
                    target2entrapment.get(target).entrapment_hits.add(pmatch);
                }else{
                    PEntrapment pentrapment = new PEntrapment();
                    pentrapment.entrapment_hits.add(pmatch);
                    target2entrapment.put(target,pentrapment);
                }
            }
            // psm_table is already sorted by q_value from min to max
            double fdr = psm_table.row(i).getDouble("q_value");
            fdr2index.put(fdr,i);
        }

        // need to add information for target paired with entrapment matches
        for(String id: id2PMatch.keySet()){
            if(id2PMatch.get(id).is_entrapment){
                // this is an entrapment match
                if(fdp_level.equals(FDRType.protein)){
                    // id is protein ID
                    // String target = PEntrapment.get_target_protein_by_entrapment_protein(id, n_fold, "_p_target", ";");
                    String target = PEntrapment.get_target_protein_by_entrapment_protein(id, n_fold, entrapment_label, ";");
                    if(id2PMatch.containsKey(target)){
                        // The target is present in the PSM table
                        target2entrapment.get(target).target_hit = id2PMatch.get(target);
                        target2entrapment.get(target).is_target_present = true;
                    }else{
                        // The target is not present in the PSM table
                        target2entrapment.get(target).is_target_present = false;
                        PMatch pMatch = new PMatch();
                        pMatch.is_entrapment = false;
                        pMatch.id = target;
                        target2entrapment.get(target).target_hit = pMatch;
                    }
                }else if(fdp_level.equals(FDRType.peptide)){
                    String target = peptidePair.get_paired_target_peptide(id);
                    if(id2PMatch.containsKey(target)){
                        // The target is present in the PSM table
                        target2entrapment.get(target).target_hit = id2PMatch.get(target);
                        target2entrapment.get(target).is_target_present = true;
                    }else{
                        // The target is not present in the PSM table
                        target2entrapment.get(target).is_target_present = false;
                        PMatch pMatch = new PMatch();
                        pMatch.is_entrapment = false;
                        pMatch.id = target;
                        target2entrapment.get(target).target_hit = pMatch;
                    }

                }else if(fdp_level.equals(FDRType.precursor)) {
                    String target_peptide = peptidePair.get_paired_target_peptide(id2PMatch.get(id).peptide);
                    int target_charge = id2PMatch.get(id).charge;
                    String target_id = target_peptide + target_charge;
                    if(id2PMatch.containsKey(target_id)) {
                        // The target is present in the PSM table
                        target2entrapment.get(target_id).target_hit = id2PMatch.get(target_id);
                        target2entrapment.get(target_id).is_target_present = true;
                    }else{
                        // The target is not present in the PSM table
                        target2entrapment.get(target_id).is_target_present = false;
                        PMatch pMatch = new PMatch();
                        pMatch.is_entrapment = false;
                        pMatch.id = target_id;
                        target2entrapment.get(target_id).target_hit = pMatch;
                    }
                }else{
                    System.err.println("FDP level is not supported: "+fdp_level);
                    System.exit(1);
                }
            }
        }

        System.out.println("The number of unique FDR values: "+fdr2index.size());

        // FDPCalcKFold.psm_map: key -> row index; value -> PMatch
        FDPCalcKFold.psm_map = psm_map;
        FDPCalcKFold.k = n_fold;
        FDPCalcKFold.target2entrapment = target2entrapment;

        //for(int i=0;i<psm_table.rowCount();i++){
        for(int i: fdr2index.values()){
            res.put(i, new HashMap<>());
            fixedThreadPool.execute(new FDPCalcKFold(i,res));
        }
        fixedThreadPool.shutdown();

        try {
            fixedThreadPool.awaitTermination(Long.MAX_VALUE, TimeUnit.HOURS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int k;
        System.out.println("\n");
        for(int i=0;i<psm_table.rowCount();i++){
            double fdr = psm_table.row(i).getDouble("q_value");
            k = fdr2index.get(fdr);
            double fdp = res.get(k).get("fdp");
            fdp_column.set(i, fdp);
            n_targets_column.set(i, res.get(k).get("n_targets").intValue());
            n_entrapment_targets_column.set(i, res.get(k).get("n_entrapment_targets").intValue());

            // ( N_{p>s} + 2 * N_{p>t>s} + N_{p>s>t} ) / (N_{p>s} + N_{t>s}).
            double fdp_1b = res.get(k).get("paired_fdp");
            fdp_1b_column.set(i, fdp_1b);

            double low_bound_fdp = res.get(k).get("low_bound_fdp");
            fdp_lower_bound_column.set(i,low_bound_fdp);

            if(n_fold==1) {
                n_p_t_s_column.set(i, res.get(k).get("n_p_t_s").intValue());
                n_p_s_t_column.set(i, res.get(k).get("n_p_s_t").intValue());
            }
            if(res.get(k).get("vt")==null){
                System.err.println("Error: vt is null:"+fdr+"\t"+i+"\t"+k);
                System.err.println("fdp:"+fdp+"\tfdp_1b:"+fdp_1b);
                System.exit(1);
            }
            n_vt_column.set(i, res.get(k).get("vt").intValue());
        }

        // q-value
        if(fdp_qvalue) {
            double cur_min_fdp = 1;
            for (int i = psm_table.rowCount() - 1; i >= 0; i--) {
                double min_fdr = Math.min(cur_min_fdp, fdp_column.get(i));
                fdp_column.set(i, min_fdr);
                cur_min_fdp = min_fdr;
            }
        }
        if(psm_table.columnNames().contains("combined_fdp")){
            psm_table.removeColumns("combined_fdp");
        }
        psm_table.addColumns(fdp_column);
        psm_table.addColumns(n_targets_column);
        psm_table.addColumns(n_entrapment_targets_column);

        if(fdp_qvalue) {
            double cur_min_fdp = 1;
            for (int i = psm_table.rowCount() - 1; i >= 0; i--) {
                double min_fdr = Math.min(cur_min_fdp, fdp_1b_column.get(i));
                fdp_1b_column.set(i, min_fdr);
                cur_min_fdp = min_fdr;
            }
        }
        if (psm_table.columnNames().contains("paired_fdp")) {
            psm_table.removeColumns("paired_fdp");
        }
        psm_table.addColumns(fdp_1b_column);
        if(n_fold==1) {
            psm_table.addColumns(n_p_t_s_column);
            psm_table.addColumns(n_p_s_t_column);
        }
        psm_table.addColumns(n_vt_column);
        psm_table.addColumns(fdp_lower_bound_column);
        psm_table.write().csv(out_file);
    }


    public void calc_fdp_fast_combined_entrapment_method(String psm_file, String pep_file, String out_file, double r){
        HashMap<String,Integer> col2index = get_column_names(psm_file,"\t");
        CsvReadOptions.Builder builder = CsvReadOptions.builder(psm_file)
                .columnTypesPartial(Collections.singletonMap("q_value", ColumnType.DOUBLE))
                .maxCharsPerColumn(10000000)
                .separator('\t')
                .header(true);
        CsvReadOptions options = builder.build();
        Table psm_table = Table.read().usingOptions(options);
        // sort the table based on q_value and a score if available
        if(!score_column_name.equalsIgnoreCase("-")) {
            System.out.println("Use both "+this.q_value_column_name+" and "+this.score_column_name + " for ranking");
            String score_rank = this.score_higher_is_better ? "-" + this.score_column_name : this.score_column_name;
            // if column name starts with "-", sort that column descending (max to min) otherwise sort ascending (min to max)
            psm_table = psm_table.sortOn(this.q_value_column_name,score_rank);
        }else{
            // min to max
            psm_table = psm_table.sortOn(this.q_value_column_name);
        }


        HashMap<String,String> target2label = new HashMap<>();
        if(this.fdp_level.equals(FDRType.precursor) ||
                this.fdp_level.equals(FDRType.psm) ||
                this.fdp_level.equals(FDRType.peptide)){
            HashSet<String> peptides = get_all_peptides(psm_file,"peptide");

            File PEPF = new File(pep_file);
            if(PEPF.isFile()) {
                System.out.println("Peptide file:"+pep_file);
                target2label = get_peptide_type(pep_file, peptides);

                if (this.fdp_level.equals(FDRType.precursor) || this.fdp_level.equals(FDRType.peptide)) {
                    peptidePair.load(pep_file, peptides);
                }
            }
        }else{
            HashSet<String> proteins = get_all_proteins(psm_file,"protein");
            File PEP_FILE = new File(pep_file);
            if(PEP_FILE.isFile()) {
                target2label = get_peptide_type(pep_file, proteins);
            }
        }
        // FDP calculation
        DoubleColumn fdp_column = DoubleColumn.create("combined_fdp", psm_table.rowCount());
        IntColumn n_targets_column = IntColumn.create("n_t", psm_table.rowCount());
        IntColumn n_entrapment_targets_column = IntColumn.create("n_p", psm_table.rowCount());
        DoubleColumn fdp_lower_bound_column = DoubleColumn.create("lower_bound_fdp", psm_table.rowCount());

        HashMap<Integer, PMatch> psm_map = new HashMap<>(psm_table.rowCount());
        HashMap<Double,Integer> fdr2index = new HashMap<>();


        // step 1

        // Store all matches: key=id, value=PMatch
        // "id" is a unique ID for each match
        // Precursor level: peptide + modification +charge or peptide + charge;
        // Peptide level: peptide;
        // Protein level: protein
        HashMap<String, PMatch> id2PMatch = new HashMap<>();

        // grouping entrapment matches based on their paired target matches if available
        for(int i=0;i<psm_table.rowCount();i++){
            PMatch pmatch = new PMatch();
            boolean is_entrapment = false;
            if(fdp_level.equals(FDRType.protein)){
                pmatch.protein = PEntrapment.format_pg(psm_table.row(i).getString("protein"),";","p_target",pick_one_protein_method);
                pmatch.id = pmatch.protein;
                is_entrapment = pmatch.id.endsWith("p_target");
            }else if(fdp_level.equals(FDRType.peptide)){
                pmatch.peptide = psm_table.row(i).getString("peptide");
                pmatch.id = psm_table.row(i).getString("peptide");
                if(!target2label.isEmpty()){
                    is_entrapment = target2label.get(pmatch.peptide).equals("p_target");
                }else{
                    // determine the type of peptide based on its protein
                    pmatch.protein = PEntrapment.format_pg(psm_table.row(i).getString("protein"),";","p_target",pick_one_protein_method);
                    is_entrapment = pmatch.protein.endsWith("p_target");
                }

            }else if(fdp_level.equals(FDRType.precursor)) {
                pmatch.peptide = psm_table.row(i).getString("peptide");
                pmatch.charge = psm_table.row(i).getInt("charge");
                pmatch.mod_peptide = psm_table.row(i).getString("mod_peptide");
                // TODO: need to update this
                pmatch.id = psm_table.row(i).getString("peptide") +"|"+ psm_table.row(i).getString("mod_peptide").length()+"|"+ psm_table.row(i).getInt("charge");
                if(!target2label.isEmpty()){
                    is_entrapment = target2label.get(pmatch.peptide).equals("p_target");
                }else{
                    // determine the type of peptide based on its protein
                    pmatch.protein = PEntrapment.format_pg(psm_table.row(i).getString("protein"),";","p_target",pick_one_protein_method);
                    is_entrapment = pmatch.protein.endsWith("p_target");
                }
            }else{
                System.err.println("FDP level is not supported: "+fdp_level);
                System.exit(1);
            }
            pmatch.is_entrapment = is_entrapment;
            psm_map.put(i,pmatch);

            pmatch.rank_score = 1.0/(i+1);
            pmatch.score_higher_is_better = true;

            id2PMatch.put(pmatch.id,pmatch);

            // psm_table is already sorted by q_value from min to max
            double fdr = psm_table.row(i).getDouble("q_value");
            fdr2index.put(fdr,i);
        }

        System.out.println("The number of unique FDR values: "+fdr2index.size());

        // FDPCalcKFold.psm_map: key -> row index; value -> PMatch
        FDPCalcCE.psm_map = psm_map;
        FDPCalcCE.r = r;

        int cpu = Runtime.getRuntime().availableProcessors();
        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(cpu);
        ConcurrentHashMap<Integer, HashMap<String, Double>> res = new ConcurrentHashMap<>(psm_table.rowCount());

        //for(int i=0;i<psm_table.rowCount();i++){
        for(int i: fdr2index.values()){
            res.put(i, new HashMap<>());
            fixedThreadPool.execute(new FDPCalcCE(i,res));
        }
        fixedThreadPool.shutdown();

        try {
            fixedThreadPool.awaitTermination(Long.MAX_VALUE, TimeUnit.HOURS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int k;
        System.out.println("\n");
        for(int i=0;i<psm_table.rowCount();i++){
            double fdr = psm_table.row(i).getDouble("q_value");
            k = fdr2index.get(fdr);
            double fdp = res.get(k).get("fdp");
            fdp_column.set(i, fdp);
            n_targets_column.set(i, res.get(k).get("n_targets").intValue());
            n_entrapment_targets_column.set(i, res.get(k).get("n_entrapment_targets").intValue());

            double low_bound_fdp = res.get(k).get("low_bound_fdp");
            fdp_lower_bound_column.set(i, low_bound_fdp);

        }

        // q-value
        if(fdp_qvalue) {
            double cur_min_fdp = 1;
            for (int i = psm_table.rowCount() - 1; i >= 0; i--) {
                double min_fdr = Math.min(cur_min_fdp, fdp_column.get(i));
                fdp_column.set(i, min_fdr);
                cur_min_fdp = min_fdr;
            }
        }
        if(psm_table.columnNames().contains("combined_fdp")){
            psm_table.removeColumns("combined_fdp");
        }
        psm_table.addColumns(fdp_column);
        psm_table.addColumns(n_targets_column);
        psm_table.addColumns(n_entrapment_targets_column);
        psm_table.addColumns(fdp_lower_bound_column);
        psm_table.write().csv(out_file);
    }


    public static HashMap<String, Integer> get_column_names(String input_file, String separator){
        HashMap<String,Integer> col2index = new HashMap<>();
        try {
            BufferedReader br = new BufferedReader(new FileReader(input_file));
            String head = br.readLine().trim();
            String []h = head.split(separator);
            for(int i=0;i<h.length;i++){
                col2index.put(h[i],i);
            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        return col2index;

    }


    public HashSet<String> get_all_peptides(String input_file, String peptide_col_name){
        HashMap<String,Integer> col2index = get_column_names(input_file,"\t");
        HashSet<String> peptides = new HashSet<>();
        try {
            BufferedReader br = new BufferedReader(new FileReader(input_file));
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                peptides.add(d[col2index.get(peptide_col_name)]);
            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        System.out.println("# of peptides: "+peptides.size());
        return peptides;
    }

    public HashSet<String> get_all_proteins(String input_file, String protein_col_name){
        HashMap<String,Integer> col2index = get_column_names(input_file,"\t");
        HashSet<String> proteins = new HashSet<>();
        try {
            BufferedReader br = new BufferedReader(new FileReader(input_file));
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                proteins.add(PEntrapment.format_pg(d[col2index.get(protein_col_name)],";","p_target",pick_one_protein_method));
                //proteins.add(d[col2index.get(protein_col_name)]);
            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        System.out.println("# of proteins: "+proteins.size());
        return proteins;
    }

    public HashMap<String, String> get_peptide_type(String pep_file, HashSet<String> peptides){
        HashMap<String,Integer> col2index = get_column_names(pep_file,"\t");
        HashMap<String,String> pep2label = new HashMap<>(peptides.size());
        try {
            BufferedReader br = new BufferedReader(new FileReader(pep_file));
            // sequence decoy proteins peptide_type peptide_pair_index
            // decoy: Yes, No
            // peptide_type: target, p_target, decoy, p_decoy
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                String peptide_seq = d[col2index.get("sequence")];
                String peptide_type = d[col2index.get("peptide_type")];
                String decoy_type = d[col2index.get("decoy")];
                if(decoy_type.startsWith("Yes")){
                    continue;
                }
                pep2label.put(peptide_seq,peptide_type);
            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return pep2label;
    }


    public HashMap<String, String> get_protein_type(String pep_file, HashSet<String> proteins){
        HashMap<String,Integer> col2index = get_column_names(pep_file,"\t");
        HashMap<String,String> pro2label = new HashMap<>(proteins.size());
        try {
            BufferedReader br = new BufferedReader(new FileReader(pep_file));
            // sequence decoy proteins peptide_type peptide_pair_index
            // decoy: Yes, No
            // peptide_type: target, p_target, decoy, p_decoy
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                String protein = d[col2index.get("proteins")];
                String peptide_type = d[col2index.get("peptide_type")];
                pro2label.put(protein,peptide_type);
            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return pro2label;
    }

    public void get_precursor_level_pair(String pep_file, String dp_library_file, HashSet<String> peptides){
        HashMap<String,Integer> col2index = get_column_names(pep_file,"\t");
        HashMap<String,String> pep2peptide_pair_index = new HashMap<>(peptides.size());
        HashMap<String,HashMap<String,String>> peptide_pair_index2peptides = new HashMap<>();
        try {
            BufferedReader br = new BufferedReader(new FileReader(pep_file));
            // sequence decoy proteins peptide_type peptide_pair_index
            // decoy: Yes, No
            // peptide_type: target, p_target, decoy, p_decoy
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                String peptide_seq = d[col2index.get("sequence")];
                if(peptides.contains(peptide_seq)){
                    String peptide_type = d[col2index.get("peptide_type")];
                    String peptide_pair_index = d[col2index.get("peptide_pair_index")];
                    pep2peptide_pair_index.put(peptide_seq,peptide_pair_index);
                    if(!peptide_pair_index2peptides.containsKey(peptide_pair_index)){
                        peptide_pair_index2peptides.put(peptide_pair_index,new HashMap<>());
                    }
                    peptide_pair_index2peptides.get(peptide_pair_index).put(peptide_type,peptide_seq);
                }

            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        // read dp library
        HashMap<String,HashMap<Integer,HashMap<Double,ArrayList<String>>>> pep2charge2mz2peptides = new HashMap<>();
        HashMap<String,Integer> dp_col2index = get_column_names(dp_library_file,"\t");
        // ModifiedPeptide: _SPEC[Carbamidomethyl]AR_
        // PrecursorCharge: 3
        // StrippedPeptide: SPECAR
        // PrecursorMz: 240.4428843058500
        try {
            BufferedReader br = new BufferedReader(new FileReader(dp_library_file));
            // sequence decoy proteins peptide_type peptide_pair_index
            // decoy: Yes, No
            // peptide_type: target, p_target, decoy, p_decoy
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                String peptide_seq = d[dp_col2index.get("StrippedPeptide")];
                if(peptides.contains(peptide_seq)){
                    int PrecursorCharge = Integer.parseInt(d[dp_col2index.get("PrecursorCharge")]);
                    String ModifiedPeptide = d[dp_col2index.get("ModifiedPeptide")];
                    double mz = Double.parseDouble(d[dp_col2index.get("PrecursorMz")]);
                    pep2charge2mz2peptides.putIfAbsent(peptide_seq,new HashMap<>());
                    pep2charge2mz2peptides.get(peptide_seq).putIfAbsent(PrecursorCharge,new HashMap<>());
                    pep2charge2mz2peptides.get(peptide_seq).get(PrecursorCharge).putIfAbsent(mz,new ArrayList<>());
                    pep2charge2mz2peptides.get(peptide_seq).get(PrecursorCharge).get(mz).add(ModifiedPeptide);
                }

            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        System.out.println("ok");
        for(String pep: peptides){
            String peptide_pair_index = pep2peptide_pair_index.get(pep);
            //System.out.println(pep);
            HashMap<String, String> p = peptide_pair_index2peptides.get(peptide_pair_index);
            if(p.keySet().size()>=2){
                // both target and entrapment target are found
                String target_pep = p.get("target");
                String entrapment_target_pep = p.get("p_target");
                System.out.println(pep+"\t"+target_pep+"\t"+entrapment_target_pep);
            }


        }



    }

    public void get_precursor_level_pair2(String pep_file, HashSet<String> peptides){
        HashMap<String,Integer> col2index = get_column_names(pep_file,"\t");
        HashMap<String,String> pep2peptide_pair_index = new HashMap<>(peptides.size());
        HashMap<String,HashMap<String,String>> peptide_pair_index2peptides = new HashMap<>();
        try {
            BufferedReader br = new BufferedReader(new FileReader(pep_file));
            // sequence decoy proteins peptide_type peptide_pair_index
            // decoy: Yes, No
            // peptide_type: target, p_target, decoy, p_decoy
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                String peptide_seq = d[col2index.get("sequence")];
                if(peptides.contains(peptide_seq)){
                    String peptide_type = d[col2index.get("peptide_type")];
                    String peptide_pair_index = d[col2index.get("peptide_pair_index")];
                    pep2peptide_pair_index.put(peptide_seq,peptide_pair_index);
                    if(!peptide_pair_index2peptides.containsKey(peptide_pair_index)){
                        peptide_pair_index2peptides.put(peptide_pair_index,new HashMap<>());
                    }
                    peptide_pair_index2peptides.get(peptide_pair_index).put(peptide_type,peptide_seq);
                }

            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        // read dp library
        HashMap<String,HashMap<Integer,HashMap<Double,ArrayList<String>>>> pep2charge2mz2peptides = new HashMap<>();
        HashMap<String,Integer> dp_col2index = get_column_names("dp_library_file","\t");
        // ModifiedPeptide: _SPEC[Carbamidomethyl]AR_
        // PrecursorCharge: 3
        // StrippedPeptide: SPECAR
        // PrecursorMz: 240.4428843058500
        try {
            BufferedReader br = new BufferedReader(new FileReader("dp_library_file"));
            // sequence decoy proteins peptide_type peptide_pair_index
            // decoy: Yes, No
            // peptide_type: target, p_target, decoy, p_decoy
            String head = br.readLine().trim();
            String line;
            while((line=br.readLine())!=null){
                String []d=line.trim().split("\t");
                String peptide_seq = d[dp_col2index.get("StrippedPeptide")];
                if(peptides.contains(peptide_seq)){
                    int PrecursorCharge = Integer.parseInt(d[dp_col2index.get("PrecursorCharge")]);
                    String ModifiedPeptide = d[dp_col2index.get("ModifiedPeptide")];
                    double mz = Double.parseDouble(d[dp_col2index.get("PrecursorMz")]);
                    pep2charge2mz2peptides.putIfAbsent(peptide_seq,new HashMap<>());
                    pep2charge2mz2peptides.get(peptide_seq).putIfAbsent(PrecursorCharge,new HashMap<>());
                    pep2charge2mz2peptides.get(peptide_seq).get(PrecursorCharge).putIfAbsent(mz,new ArrayList<>());
                    pep2charge2mz2peptides.get(peptide_seq).get(PrecursorCharge).get(mz).add(ModifiedPeptide);
                }

            }
            br.close();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }

        System.out.println("ok");
        for(String pep: peptides){
            String peptide_pair_index = pep2peptide_pair_index.get(pep);
            //System.out.println(pep);
            HashMap<String, String> p = peptide_pair_index2peptides.get(peptide_pair_index);
            if(p.keySet().size()>=2){
                // both target and entrapment target are found
                String target_pep = p.get("target");
                String entrapment_target_pep = p.get("p_target");
                System.out.println(pep+"\t"+target_pep+"\t"+entrapment_target_pep);
            }


        }



    }

    public static void load_valid_target_peptides(String pep_file) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(pep_file));
        String line = reader.readLine().trim();
        // target	decoy(s)	mass	proteins
        String [] header = line.split("\t");
        HashMap<String,Integer> col_name2index = new HashMap<>();
        for (int i = 0; i < header.length; i++) {
            col_name2index.put(header[i], i);
        }
        HashMap<String, HashSet<String>> target_peptide2random_peptides = new HashMap<>();
        while ((line = reader.readLine()) != null) {
            String [] fields = line.split("\t");
            String peptide = fields[col_name2index.get("sequence")];
            if(col_name2index.containsKey("peptide_type")){
                if(!fields[col_name2index.get("peptide_type")].equals("target")){
                    continue;
                }
            }
            valid_target_peptides.add(peptide);
        }
        reader.close();

    }



    public static ArrayList<String> generateShufflePeptidesFast(String pep_seq, int num, boolean fixCtermAA, HashSet<String> all_peptides){
        ArrayList<String> randomPeptides = new ArrayList<>();
        // save all random peptides generated so far no matter they are valid or not
        HashSet<String> randomPeptides_generated = new HashSet<>();
        String peptideSequence = pep_seq;
        int peptideLength = peptideSequence.length();

        // No change for c-term amino acid
        if(fixCtermAA){
            peptideLength = peptideLength - 1;
            peptideSequence = peptideSequence.substring(0,peptideLength);
        }

        // the max times to try
        int max_n = 20+num;
        int max_n_i = 0;

        String rnd_peptide = "";
        for(int n=0;n<num;n++){
            ArrayList<String> aa_list = new ArrayList<>(peptideLength);
            for(int i=0;i<peptideLength;i++){
                aa_list.add(String.valueOf(peptideSequence.charAt(i)));
            }
            Collections.shuffle(aa_list, new Random(n+2023));
            rnd_peptide = StringUtils.join(aa_list,"");
            if(fixCtermAA){
                rnd_peptide = rnd_peptide + pep_seq.charAt(pep_seq.length()-1);
            }
            if(!all_peptides.contains(rnd_peptide) && !randomPeptides_generated.contains(rnd_peptide)){
                randomPeptides_generated.add(rnd_peptide);
                randomPeptides.add(rnd_peptide);
            }else{
                n--;
            }

            max_n_i++;
            if(max_n_i>=max_n){
                break;
            }

        }

        return(randomPeptides);
    }


    public static ArrayList<String> generateShufflePeptidesFast(String pep_seq, int num, boolean fixCtermAA, boolean fixNtermAA,  HashSet<String> all_peptides, Random random_obj, int n_max_try){
        ArrayList<String> randomPeptides = new ArrayList<>();
        // save all random peptides generated so far no matter they are valid or not
        HashSet<String> randomPeptides_generated = new HashSet<>();
        String peptideSequence = pep_seq;
        int peptideLength = peptideSequence.length();

        // No change for c-term amino acid
        if(fixCtermAA){
            peptideLength = peptideLength - 1;
            peptideSequence = peptideSequence.substring(0,peptideLength);
        }

        if(fixNtermAA){
            peptideSequence = peptideSequence.substring(1,peptideLength);
            peptideLength = peptideLength - 1;
        }

        if(peptideLength==2){
            String rnd_peptide = StringUtils.reverse(peptideSequence);
            if (fixCtermAA) {
                rnd_peptide = rnd_peptide + pep_seq.charAt(pep_seq.length() - 1);
            }
            if (fixNtermAA) {
                rnd_peptide = pep_seq.charAt(0) + rnd_peptide;
            }
            if (!all_peptides.contains(rnd_peptide)){
                randomPeptides.add(rnd_peptide);
            }
        }else {

            // the max times to try
            int max_n = n_max_try + num;
            int max_n_i = 0;

            String rnd_peptide = "";
            int k = 0;
            int n = 0;
            while (n < num) {
                n++;
                //for(int n=0;n<num;n++){
                k++;
                ArrayList<String> aa_list = new ArrayList<>(peptideLength);
                for (int i = 0; i < peptideLength; i++) {
                    aa_list.add(String.valueOf(peptideSequence.charAt(i)));
                }
                Collections.shuffle(aa_list, random_obj);
                rnd_peptide = StringUtils.join(aa_list, "");
                if (fixCtermAA) {
                    rnd_peptide = rnd_peptide + pep_seq.charAt(pep_seq.length() - 1);
                }
                if (fixNtermAA) {
                    rnd_peptide = pep_seq.charAt(0) + rnd_peptide;
                }
                if (!all_peptides.contains(rnd_peptide) && !randomPeptides_generated.contains(rnd_peptide)) {
                    randomPeptides_generated.add(rnd_peptide);
                    randomPeptides.add(rnd_peptide);
                } else {
                    n--;
                }

                max_n_i++;
                if (max_n_i >= max_n) {
                    break;
                }

            }
        }

        return(randomPeptides);
    }


    public static ArrayList<String> generateShufflePeptidesFastSwap(String pep_seq, int num, boolean fixCtermAA, boolean fixNtermAA,  HashSet<String> all_peptides, Random random_obj, int n_max_try){
        ArrayList<String> randomPeptides = new ArrayList<>();
        // save all random peptides generated so far no matter they are valid or not
        HashSet<String> randomPeptides_generated = new HashSet<>();
        String peptideSequence = pep_seq;
        int peptideLength = peptideSequence.length();

        // No change for c-term amino acid
        if(fixCtermAA){
            peptideLength = peptideLength - 1;
            peptideSequence = peptideSequence.substring(0,peptideLength);
        }

        if(fixNtermAA){
            peptideSequence = peptideSequence.substring(1,peptideLength);
            peptideLength = peptideLength - 1;
        }

        int i_try = 0;
        if(peptideLength<=2){
            String rnd_peptide = StringUtils.reverse(peptideSequence);
            if (fixCtermAA) {
                rnd_peptide = rnd_peptide + pep_seq.charAt(pep_seq.length() - 1);
            }
            if (fixNtermAA) {
                rnd_peptide = pep_seq.charAt(0) + rnd_peptide;
            }
            if (!all_peptides.contains(rnd_peptide)){
                randomPeptides.add(rnd_peptide);
            }
        }else {

            // the max times to try
            int max_n = n_max_try + num;
            int max_n_i = 0;

            String rnd_peptide = "";
            int k = 0;
            int n = 0;
            while (n < num) {
                n++;
                //for(int n=0;n<num;n++){
                k++;
                ArrayList<String> aa_list = new ArrayList<>(peptideLength);
                for (int i = 0; i < peptideLength; i++) {
                    aa_list.add(String.valueOf(peptideSequence.charAt(i)));
                }
                // Collections.shuffle(aa_list, random_obj);

                for(int i=0;i<aa_list.size();i++){
                    int j = random_obj.nextInt(aa_list.size());
                    i_try = 0;
                    while (j == i) {
                        i_try++;
                        j = random_obj.nextInt(aa_list.size());
                        if(i_try>=1000){
                            System.out.println("Target sequence:"+pep_seq);
                            System.out.println("Working on sequence:"+peptideSequence);
                            break;
                        }
                    }
                    String temp_aa = aa_list.get(i);
                    aa_list.set(i, aa_list.get(j));
                    aa_list.set(j,temp_aa);
                }
                rnd_peptide = StringUtils.join(aa_list, "");
                if (fixCtermAA) {
                    rnd_peptide = rnd_peptide + pep_seq.charAt(pep_seq.length() - 1);
                }
                if (fixNtermAA) {
                    rnd_peptide = pep_seq.charAt(0) + rnd_peptide;
                }
                if (!all_peptides.contains(rnd_peptide) && !randomPeptides_generated.contains(rnd_peptide)) {
                    randomPeptides_generated.add(rnd_peptide);
                    randomPeptides.add(rnd_peptide);
                } else {
                    n--;
                }

                max_n_i++;
                if (max_n_i >= max_n) {
                    break;
                }

            }
        }

        return(randomPeptides);
    }
}

